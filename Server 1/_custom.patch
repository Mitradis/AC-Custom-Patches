diff --git a/.gitignore b/.gitignore
index 8d6ed8f..c0e7d20 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,17 +1,16 @@
 #
 # AzerothCore
 #
 
 /conf/*
 !/conf/dist
-/modules/*
 !/modules/*.md
 !/modules/*.sh
 !/modules/CMakeLists.txt
 !/modules/*.h
 !/modules/*.cmake
 /build*/
 /var/*
 !/var/build/.gitkeep
 !/var/ccache/.gitkeep
 /env/dist/*
diff --git a/src/common/Banner.cpp b/src/common/Banner.cpp
index 65f5ab5..8bff3ea 100644
--- a/src/common/Banner.cpp
+++ b/src/common/Banner.cpp
@@ -16,31 +16,18 @@
  */
 
 #include "Banner.h"
 #include "GitRevision.h"
 #include "StringFormat.h"
 
 void Acore::Banner::Show(std::string_view applicationName, void(*log)(std::string_view text), void(*logExtraInfo)())
 {
     log(Acore::StringFormat("{} ({})", GitRevision::GetFullVersion(), applicationName));
     log("<Ctrl-C> to stop.\n");
-    log("   █████╗ ███████╗███████╗██████╗  ██████╗ ████████╗██╗  ██╗");
-    log("  ██╔══██╗╚══███╔╝██╔════╝██╔══██╗██╔═══██╗╚══██╔══╝██║  ██║");
-    log("  ███████║  ███╔╝ █████╗  ██████╔╝██║   ██║   ██║   ███████║");
-    log("  ██╔══██║ ███╔╝  ██╔══╝  ██╔══██╗██║   ██║   ██║   ██╔══██║");
-    log("  ██║  ██║███████╗███████╗██║  ██║╚██████╔╝   ██║   ██║  ██║");
-    log("  ╚═╝  ╚═╝╚══════╝╚══════╝╚═╝  ╚═╝ ╚═════╝    ╚═╝   ╚═╝  ╚═╝");
-    log("                                 ██████╗ ██████╗ ██████╗ ███████╗");
-    log("                                ██╔════╝██╔═══██╗██╔══██╗██╔════╝");
-    log("                                ██║     ██║   ██║██████╔╝█████╗");
-    log("                                ██║     ██║   ██║██╔══██╗██╔══╝");
-    log("                                ╚██████╗╚██████╔╝██║  ██║███████╗");
-    log("                                 ╚═════╝ ╚═════╝ ╚═╝  ╚═╝╚══════╝\n");
-    log("     AzerothCore 3.3.5a  -  www.azerothcore.org\n");
 
     if (logExtraInfo)
     {
         logExtraInfo();
     }
 
     log(" ");
 }
diff --git a/src/server/apps/worldserver/worldserver.conf.dist b/src/server/apps/worldserver/worldserver.conf.dist
index 484c473..a06d285 100644
--- a/src/server/apps/worldserver/worldserver.conf.dist
+++ b/src/server/apps/worldserver/worldserver.conf.dist
@@ -2171,20 +2171,27 @@ ToggleXP.Cost = 100000
 
 SpellQueue.Enabled = 1
 
 #
 #    SpellQueue.Window
 #        Description: Time (in milliseconds) for spells to be queued.
 #        Default:     400 - (400ms)
 
 SpellQueue.Window = 400
 
+#
+#    MountCheckInterval
+#        Description: Time (in milliseconds) before apply mount camera height client fix
+#        Default:     20 - (20ms)
+
+MountCheckInterval = 20
+
 #
 ###################################################################################################
 
 ###################################################################################################
 # SKILL
 #
 #    MaxPrimaryTradeSkill
 #        Description: Maximum number of primary professions a character can learn.
 #        Range:       0-11
 #        Default:     2
@@ -2258,20 +2265,29 @@ SkillChance.SkinningSteps = 0
 
 #
 #    OffhandCheckAtSpellUnlearn
 #        Description: Unlearning certain spells can change offhand weapon restrictions
 #                     for equip slots.
 #        Default:     1 - (Recheck offhand slot weapon at unlearning a spell)
 #                     0 - (Recheck offhand slot weapon only at zone update)
 
 OffhandCheckAtSpellUnlearn = 1
 
+#
+#    TransferComboPoints
+#        Description: Transfer combo points on new target
+#        Default:     0 - Vanilla
+#                     1 - Transfer only for NPC
+#                     2 - Transfer for all
+
+TransferComboPoints = 1
+
 #
 ###################################################################################################
 
 ###################################################################################################
 # STATS
 #
 #    Stats.Limits.Enable
 #        Description: Enable or disable stats system limitations
 #        Default:     0 - Disabled
 #                     1 - Enabled
@@ -2576,20 +2592,28 @@ Death.Bones.BattlegroundOrArena = 1
 ###################################################################################################
 # PET
 #
 #     Pet.RankMod.Health
 #        Description: Allows pet health to be modified by rank health rates (set in config)
 #        Default:     1 - Enabled
 #                     0 - Disabled
 
 Pet.RankMod.Health = 1
 
+#
+#    Pet.Threat.Redirect
+#        Description: Redirect threat percent from player to pet if pet is alive
+#        Default:     40 (0-99)
+#
+
+Pet.Threat.Redirect = 40
+
 #
 ###################################################################################################
 
 ###################################################################################################
 # ITEM DELETE
 #
 #    ItemDelete.Method
 #        Description: Item deletion behavior.
 #        Default:     0 - (Completely remove item from the database)
 #                     1 - (Save Item to database)
@@ -2791,20 +2815,29 @@ Rate.RewardQuestMoney = 1
 #                     is at MaxPlayerLevel.
 #        Default:     1
 
 Rate.RewardBonusMoney = 1
 
 #
 ###################################################################################################
 
 ###################################################################################################
 # CREATURE
+#
+#    ThreatRadius
+#        Description: Distance for creatures to evade after being pulled away from the combat
+#                     starting point. If ThreatRadius is less than creature aggro radius then aggro
+#                     radius will be used.
+#        Default:     60
+
+ThreatRadius = 60
+
 #
 #     MonsterSight
 #        Description: The maximum distance in yards that a "monster" creature can see
 #                     regardless of level difference (through CreatureAI::IsVisible).
 #                     Increases CONFIG_SIGHT_MONSTER to 50 yards. Used to be 20 yards.
 #        Default:     50.000000
 
 MonsterSight = 50.000000
 
 #
@@ -3199,29 +3232,20 @@ Instance.SharedNormalHeroicId = 1
 #    DungeonAccessRequirements.PrintMode
 #
 #        Description: Select the preferred format to display information to the player who cannot enter a portal dungeon because when has not met the access requirements:
 #        Default:     1 - (Display only one requirement at a time (BlizzLike, like in the LFG interface))
 #                     0 - (Display no extra information, only "Requirements  not met")
 #                     2 - (Display detailed requirements, all at once, with clickable links)
 #
 
 DungeonAccessRequirements.PrintMode = 1
 
-#
-#    DungeonAccessRequirements.PortalAvgIlevelCheck
-#
-#        Description: Enable average item level requirement when entering a dungeon/raid's portal (= deny the entry if player has too low average ilevel, like in LFG).
-#        Default:     0 - (Disabled  -> Blizzlike)
-#                     1 - (Enabled)
-
-DungeonAccessRequirements.PortalAvgIlevelCheck = 0
-
 #
 #    DungeonAccessRequirements.OptionalStringID
 #
 #        Description: Display an extra message from acore_strings in the chat after printing the dungeon access requirements.
 #                     To enable it set the ID of your desired string from the table acore_strings
 #        Default:     0 - (Disabled)
 #                     1+ - (Enabled)
 
 DungeonAccessRequirements.OptionalStringID = 0
 
@@ -4433,34 +4457,42 @@ MunchingBlizzlike.Enabled = 1
 
 Daze.Enabled = 1
 
 #
 ###################################################################################################
 
 ###################################################################################################
 # DEBUG
 #
 #    Debug.Battleground
-#        Description: Enable or disable Battleground 1v0 mode. (If enabled, the in-game command is disabled.)
+#        Description: Enable or disable Battleground 1v0 mode.
 #        Default: 0 - (Disabled)
 #                 1 - (Enabled)
 
 Debug.Battleground = 0
 
 #
 #    Debug.Arena
-#        Description: Enable or disable Arena 1v1 mode. (If enabled, the in-game command is disabled.)
+#        Description: Enable or disable Arena 1v1 mode.
 #        Default: 0 - (Disabled)
 #                 1 - (Enabled)
 
 Debug.Arena = 0
 
+#
+#    Debug.LFG
+#        Description: Enable or disable LFG solo mode.
+#        Default: 0 - (Disabled)
+#                 1 - (Enabled)
+
+Debug.LFG = 0
+
 #
 ###################################################################################################
 
 ###################################################################################################
 # DYNAMIC RESPAWN SETTINGS
 #
 #
 #    Respawn.DynamicRateCreature
 #        Description: Controls how creature respawn times adjust based on player count in a zone.
 #                     The respawn time is unchanged up to the configured number of players.
diff --git a/src/server/database/Database/DatabaseLoader.cpp b/src/server/database/Database/DatabaseLoader.cpp
index 5ad77d3..4ec4012 100644
--- a/src/server/database/Database/DatabaseLoader.cpp
+++ b/src/server/database/Database/DatabaseLoader.cpp
@@ -146,23 +146,20 @@ DatabaseLoader& DatabaseLoader::AddDatabase(DatabaseWorkerPool<T>& pool, std::st
         }
 
         return true;
     });
 
     return *this;
 }
 
 bool DatabaseLoader::Load()
 {
-    if (!_updateFlags)
-        LOG_WARN("sql.updates", "> AUTOUPDATER: Automatic database updates are disabled for all databases in the config! This is not recommended!");
-
     if (!OpenDatabases())
         return false;
 
     if (!PopulateDatabases())
         return false;
 
     if (!UpdateDatabases())
         return false;
 
     if (!PrepareStatements())
diff --git a/src/server/game/AI/CreatureAI.cpp b/src/server/game/AI/CreatureAI.cpp
index 82d8279..6f1cdd2 100644
--- a/src/server/game/AI/CreatureAI.cpp
+++ b/src/server/game/AI/CreatureAI.cpp
@@ -304,21 +304,22 @@ bool CreatureAI::_EnterEvadeMode(EvadeReason /*why*/)
 {
     if (!me->IsAlive())
     {
         return false;
     }
 
     // don't remove vehicle auras, passengers aren't supposed to drop off the vehicle
     // don't remove clone caster on evade (to be verified)
     me->RemoveEvadeAuras();
 
-    me->ClearComboPointHolders(); // Remove all combo points targeting this unit
+    if (sWorld->getIntConfig(CONFIG_TRANSFER_COMBOPOINTS) < 1)
+        me->ClearComboPointHolders(); // Remove all combo points targeting this unit
     // sometimes bosses stuck in combat?
     me->GetThreatMgr().ClearAllThreat();
     me->CombatStop(true);
     me->LoadCreaturesAddon(true);
     me->SetLootRecipient(nullptr);
     me->ResetPlayerDamageReq();
     me->ClearLastLeashExtensionTimePtr();
     me->SetCannotReachTarget();
 
     if (ZoneScript* zoneScript = me->GetZoneScript() ? me->GetZoneScript() : (ZoneScript*)me->GetInstanceScript())
diff --git a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
index f922e77..b30e4de 100644
--- a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
+++ b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
@@ -113,20 +113,30 @@ uint32 AuctionHouseMgr::GetAuctionDeposit(AuctionHouseEntry const* entry, uint32
 
 //does not clear ram
 void AuctionHouseMgr::SendAuctionWonMail(AuctionEntry* auction, CharacterDatabaseTransaction trans, bool sendNotification, bool updateAchievementCriteria, bool sendMail)
 {
     Item* pItem = GetAItem(auction->item_guid);
     if (!pItem)
         return;
 
     uint32 bidder_accId = 0;
     Player* bidder = ObjectAccessor::FindConnectedPlayer(auction->bidder);
+    if (auction->owner.GetCounter() == 0)
+    {
+        Item* dItem = Item::CreateItem(pItem->GetEntry(), pItem->GetCount());
+        dItem->SaveToDB(trans);
+        MailDraft(auction->BuildAuctionMailSubject(AUCTION_WON), AuctionEntry::BuildAuctionMailBody(auction->owner, auction->bid, auction->buyout))
+            .AddItem(dItem)
+            .SendMailTo(trans, MailReceiver(bidder, auction->bidder.GetCounter()), auction, MAIL_CHECK_MASK_COPIED);
+        auction->bidder = ObjectGuid::Empty;;
+        return;
+    }
     if (bidder)
         bidder_accId = bidder->GetSession()->GetAccountId();
     else
         bidder_accId = sCharacterCache->GetCharacterAccountIdByGuid(auction->bidder);
 
     // receiver exist
     if (bidder || bidder_accId)
     {
         sScriptMgr->OnBeforeAuctionHouseMgrSendAuctionWonMail(this, auction, bidder, bidder_accId, sendNotification, updateAchievementCriteria, sendMail);
         // set owner to bidder (to prevent delete item with sender char deleting)
@@ -509,21 +519,21 @@ void AuctionHouseObject::Update()
     if (_auctionsMap.empty())
         return;
 
     CharacterDatabaseTransaction trans = CharacterDatabase.BeginTransaction();
 
     for (AuctionEntryMap::iterator itr, iter = _auctionsMap.begin(); iter != _auctionsMap.end(); )
     {
         itr = iter++;
         AuctionEntry* auction = (*itr).second;
 
-        if (auction->expire_time > checkTime)
+        if (auction->expire_time > checkTime || auction->owner.GetCounter() == 0)
             continue;
 
         ///- Either cancel the auction if there was no bidder
         if (!auction->bidder)
         {
             sAuctionMgr->SendAuctionExpiredMail(auction, trans);
             sScriptMgr->OnAuctionExpire(this, auction);
         }
         ///- Or perform the transaction
         else
diff --git a/src/server/game/AuctionHouse/AuctionHouseSearcher.cpp b/src/server/game/AuctionHouse/AuctionHouseSearcher.cpp
index 0d50d7e..44cc234 100644
--- a/src/server/game/AuctionHouse/AuctionHouseSearcher.cpp
+++ b/src/server/game/AuctionHouse/AuctionHouseSearcher.cpp
@@ -446,21 +446,21 @@ void SearchableAuctionEntry::BuildAuctionInfo(WorldPacket& data) const
     data << int32(item.randomPropertyId);                           // Random item property id
     data << uint32(item.suffixFactor);                              // SuffixFactor
     data << uint32(item.count);                                     // item->count
     data << uint32(item.spellCharges);                              // item->charge FFFFFFF
     data << uint32(0);                                              // item->flags (client doesnt do anything with it)
     data << ownerGuid;                                              // Auction->owner
     data << uint32(startbid);                                       // Auction->startbid (not sure if useful)
     data << uint32(bid ? AuctionEntry::CalculateAuctionOutBid(bid) : 0);
     // Minimal outbid
     data << uint32(buyout);                                         // Auction->buyout
-    data << uint32((expire_time - GameTime::GetGameTime().count()) * IN_MILLISECONDS); // time left
+    data << uint32((ownerGuid.GetCounter() == 0 ? 172800 : expire_time - GameTime::GetGameTime().count()) * IN_MILLISECONDS); // time left
     data << bidderGuid;                                             // auction->bidder current
     data << uint32(bid);                                            // current bid
 }
 
 void SearchableAuctionEntry::SetItemNames()
 {
     ItemTemplate const* proto = item.itemTemplate;
     ItemLocale const* il = sObjectMgr->GetItemLocale(proto->ItemId);
 
     for (uint32 locale = 0; locale < TOTAL_LOCALES; ++locale)
diff --git a/src/server/game/Battlefield/Battlefield.cpp b/src/server/game/Battlefield/Battlefield.cpp
index 0b25e18..aa104d5 100644
--- a/src/server/game/Battlefield/Battlefield.cpp
+++ b/src/server/game/Battlefield/Battlefield.cpp
@@ -169,21 +169,20 @@ bool Battlefield::Update(uint32 diff)
         InvitePlayersInZoneToQueue();
         OnStartGrouping();
     }
 
     bool objective_changed = false;
     if (IsWarTime())
     {
         if (m_uiKickAfkPlayersTimer <= diff)
         {
             m_uiKickAfkPlayersTimer = 20000;
-            KickAfkPlayers();
         }
         else
             m_uiKickAfkPlayersTimer -= diff;
 
         // Kick players who chose not to accept invitation to the battle
         if (m_uiKickDontAcceptTimer <= diff)
         {
             time_t now = GameTime::GetGameTime().count();
             for (int team = 0; team < 2; team++)
                 for (PlayerTimerMap::iterator itr = m_InvitedPlayers[team].begin(); itr != m_InvitedPlayers[team].end(); ++itr)
diff --git a/src/server/game/Battlegrounds/Battleground.cpp b/src/server/game/Battlegrounds/Battleground.cpp
index 1d87e34..c15311d 100644
--- a/src/server/game/Battlegrounds/Battleground.cpp
+++ b/src/server/game/Battlegrounds/Battleground.cpp
@@ -489,40 +489,33 @@ inline void Battleground::_ProcessJoin(uint32 diff)
         // Setup here, only when at least one player has ported to the map
         if (!SetupBattleground())
         {
             EndNow();
             return;
         }
 
         StartingEventCloseDoors();
         SetStartDelayTime(StartDelayTimes[BG_STARTING_EVENT_FIRST]);
 
-        // First start warning - 2 or 1 minute
-        if (StartMessageIds[BG_STARTING_EVENT_FIRST])
-            SendBroadcastText(StartMessageIds[BG_STARTING_EVENT_FIRST], CHAT_MSG_BG_SYSTEM_NEUTRAL);
+        if (StartMessageIds[BG_STARTING_EVENT_THIRD])
+            SendBroadcastText(StartMessageIds[BG_STARTING_EVENT_THIRD], CHAT_MSG_BG_SYSTEM_NEUTRAL);
     }
     // After 1 minute or 30 seconds, warning is signaled
     else if (GetStartDelayTime() <= StartDelayTimes[BG_STARTING_EVENT_SECOND] && !(m_Events & BG_STARTING_EVENT_2))
     {
         m_Events |= BG_STARTING_EVENT_2;
-
-        if (StartMessageIds[BG_STARTING_EVENT_SECOND])
-            SendBroadcastText(StartMessageIds[BG_STARTING_EVENT_SECOND], CHAT_MSG_BG_SYSTEM_NEUTRAL);
     }
     // After 30 or 15 seconds, warning is signaled
     else if (GetStartDelayTime() <= StartDelayTimes[BG_STARTING_EVENT_THIRD] && !(m_Events & BG_STARTING_EVENT_3))
     {
         m_Events |= BG_STARTING_EVENT_3;
 
-        if (StartMessageIds[BG_STARTING_EVENT_THIRD])
-            SendBroadcastText(StartMessageIds[BG_STARTING_EVENT_THIRD], CHAT_MSG_BG_SYSTEM_NEUTRAL);
-
         if (isArena())
             switch (GetBgTypeID())
             {
                 case BATTLEGROUND_NA:
                     DelObject(BG_NA_OBJECT_READY_MARKER_1);
                     DelObject(BG_NA_OBJECT_READY_MARKER_2);
                     break;
                 case BATTLEGROUND_BE:
                     DelObject(BG_BE_OBJECT_READY_MARKER_1);
                     DelObject(BG_BE_OBJECT_READY_MARKER_2);
diff --git a/src/server/game/Battlegrounds/Battleground.h b/src/server/game/Battlegrounds/Battleground.h
index 5e1d00f..9efc318 100644
--- a/src/server/game/Battlegrounds/Battleground.h
+++ b/src/server/game/Battlegrounds/Battleground.h
@@ -170,24 +170,24 @@ enum BattlegroundTimeIntervals
     RESPAWN_IMMEDIATELY             = 0,                    // secs
 };
 
 #define RESURRECTION_INTERVAL (sWorld->getIntConfig(CONFIG_BATTLEGROUND_PLAYER_RESPAWN) * IN_MILLISECONDS)
 #define RESTORATION_BUFF_RESPAWN_TIME (sWorld->getIntConfig(CONFIG_BATTLEGROUND_RESTORATION_BUFF_RESPAWN))
 #define BERSERKING_BUFF_RESPAWN_TIME (sWorld->getIntConfig(CONFIG_BATTLEGROUND_BERSERKING_BUFF_RESPAWN))
 #define SPEED_BUFF_RESPAWN_TIME (sWorld->getIntConfig(CONFIG_BATTLEGROUND_SPEED_BUFF_RESPAWN))
 
 enum BattlegroundStartTimeIntervals
 {
-    BG_START_DELAY_2M               = 120000,               // ms (2 minutes)
-    BG_START_DELAY_1M               = 60000,                // ms (1 minute)
-    BG_START_DELAY_30S              = 30000,                // ms (30 seconds)
-    BG_START_DELAY_15S              = 15000,                // ms (15 seconds) Used only in arena
+    BG_START_DELAY_2M               = 30000,                // ms (2 minutes)
+    BG_START_DELAY_1M               = 15000,                // ms (1 minute)
+    BG_START_DELAY_30S              = 10000,                // ms (30 seconds)
+    BG_START_DELAY_15S              = 5000,                 // ms (15 seconds) Used only in arena
     BG_START_DELAY_NONE             = 0,                    // ms
 };
 
 #define BATTLEGROUND_UPDATE_INTERVAL 1000
 
 enum BattlegroundBuffObjects
 {
     BG_OBJECTID_SPEEDBUFF_ENTRY     = 179871,
     BG_OBJECTID_REGENBUFF_ENTRY     = 179904,
     BG_OBJECTID_BERSERKERBUFF_ENTRY = 179905
diff --git a/src/server/game/Battlegrounds/BattlegroundMgr.cpp b/src/server/game/Battlegrounds/BattlegroundMgr.cpp
index 46bac26..fb514af 100644
--- a/src/server/game/Battlegrounds/BattlegroundMgr.cpp
+++ b/src/server/game/Battlegrounds/BattlegroundMgr.cpp
@@ -52,22 +52,22 @@
 bool BattlegroundTemplate::IsArena() const
 {
     return BattlemasterEntry->type == MAP_ARENA;
 }
 
 /*********************************************************/
 /***            BATTLEGROUND MANAGER                   ***/
 /*********************************************************/
 
 BattlegroundMgr::BattlegroundMgr() :
-    m_ArenaTesting(false),
-    m_Testing(false),
+    m_ArenaTesting(sWorld->getBoolConfig(CONFIG_DEBUG_ARENA)),
+    m_Testing(sWorld->getBoolConfig(CONFIG_DEBUG_BATTLEGROUND)),
     m_NextAutoDistributionTime(0),
     m_AutoDistributionTimeChecker(0),
     m_NextPeriodicQueueUpdateTime(5 * IN_MILLISECONDS)
 {
 }
 
 BattlegroundMgr::~BattlegroundMgr()
 {
     DeleteAllBattlegrounds();
 }
@@ -724,44 +724,28 @@ uint8 BattlegroundMgr::BGArenaType(BattlegroundQueueTypeId bgQueueTypeId)
         arenaType = BattlegroundMgr::QueueToArenaType.at(bgQueueTypeId);
     }
 
     sScriptMgr->OnArenaQueueIdToArenaType(bgQueueTypeId, arenaType);
 
     return arenaType;
 }
 
 void BattlegroundMgr::ToggleTesting()
 {
-    if (sWorld->getBoolConfig(CONFIG_DEBUG_BATTLEGROUND))
-    {
-        m_Testing = true;
-        ChatHandler(nullptr).SendWorldText(LANG_DEBUG_BG_CONF);
-    }
-    else
-    {
-        m_Testing = !m_Testing;
-        ChatHandler(nullptr).SendWorldText(m_Testing ? LANG_DEBUG_BG_ON : LANG_DEBUG_BG_OFF);
-    }
+    m_Testing = !m_Testing;
+    ChatHandler(nullptr).SendWorldText(m_Testing ? LANG_DEBUG_BG_ON : LANG_DEBUG_BG_OFF);
 }
 
 void BattlegroundMgr::ToggleArenaTesting()
 {
-    if (sWorld->getBoolConfig(CONFIG_DEBUG_ARENA))
-    {
-        m_ArenaTesting = true;
-        ChatHandler(nullptr).SendWorldText(LANG_DEBUG_ARENA_CONF);
-    }
-    else
-    {
-        m_ArenaTesting = !m_ArenaTesting;
-        ChatHandler(nullptr).SendWorldText(m_ArenaTesting ? LANG_DEBUG_ARENA_ON : LANG_DEBUG_ARENA_OFF);
-    }
+    m_ArenaTesting = !m_ArenaTesting;
+    ChatHandler(nullptr).SendWorldText(m_ArenaTesting ? LANG_DEBUG_ARENA_ON : LANG_DEBUG_ARENA_OFF);
 }
 
 void BattlegroundMgr::SetHolidayWeekends(uint32 mask)
 {
     for (uint32 bgtype = 1; bgtype < MAX_BATTLEGROUND_TYPE_ID; ++bgtype)
     {
         if (bgtype == BATTLEGROUND_RB)
             continue;
         if (Battleground* bgt = GetBattlegroundTemplate(BattlegroundTypeId(bgtype)))
             bgt->SetHoliday(mask & (1 << bgtype));
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundSA.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundSA.cpp
index 0d6e808..5e87c71 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundSA.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundSA.cpp
@@ -19,34 +19,33 @@
 #include "Chat.h"
 #include "GameGraveyard.h"
 #include "GameObject.h"
 #include "GameTime.h"
 #include "Language.h"
 #include "ObjectMgr.h"
 #include "Player.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
-constexpr Milliseconds BG_SA_BOAT_START    = 1min;
-constexpr Milliseconds BG_SA_WARMUPLENGTH  = 2min;
+constexpr Milliseconds BG_SA_BOAT_START    = 0s;
+constexpr Milliseconds BG_SA_WARMUPLENGTH  = 60s;
 constexpr Milliseconds BG_SA_ROUNDLENGTH   = 10min;
 
 void BattlegroundSAScore::BuildObjectivesBlock(WorldPacket& data)
 {
     data << uint32(2); // Objectives Count
     data << uint32(DemolishersDestroyed);
     data << uint32(GatesDestroyed);
 }
 
 BattlegroundSA::BattlegroundSA()
 {
-    StartMessageIds[BG_STARTING_EVENT_FOURTH] = 0;
     BgObjects.resize(BG_SA_MAXOBJ);
     BgCreatures.resize(static_cast<uint16>(BG_SA_MAXNPC) + BG_SA_MAX_GY);
     TimerEnabled = false;
     UpdateWaitTimer = 0;
     SignaledRoundTwo = false;
     SignaledRoundTwoHalfMin = false;
     InitSecondRound = false;
     Attackers = TEAM_ALLIANCE;
     TotalTime = 0s;
     EndRoundTimer = 0s;
diff --git a/src/server/game/Chat/ChatCommands/ChatCommand.cpp b/src/server/game/Chat/ChatCommands/ChatCommand.cpp
index c15e4d9..70c8f87 100644
--- a/src/server/game/Chat/ChatCommands/ChatCommand.cpp
+++ b/src/server/game/Chat/ChatCommands/ChatCommand.cpp
@@ -152,45 +152,62 @@ void Acore::Impl::ChatCommands::ChatCommandNode::ResolveNames(std::string name)
     }
 }
 
 static void LogCommandUsage(WorldSession const& session, std::string_view cmdStr)
 {
     if (AccountMgr::IsPlayerAccount(session.GetSecurity()))
         return;
 
     Player* player = session.GetPlayer();
     ObjectGuid targetGuid = player->GetTarget();
-    uint32 areaId = player->GetAreaId();
-    uint32 zoneId = player->GetZoneId();
-    std::string areaName = "Unknown";
-    std::string zoneName = "Unknown";
-    LocaleConstant locale = sWorld->GetDefaultDbcLocale();
 
-    if (AreaTableEntry const* area = sAreaTableStore.LookupEntry(areaId))
+    std::string logMessage = "Command: " + std::string(cmdStr) + " Player: " + player->GetName();
+    if (player->GetSelectedUnit())
     {
-        areaName = area->area_name[locale];
-    }
-
-    if (AreaTableEntry const* zone = sAreaTableStore.LookupEntry(zoneId))
-    {
-        zoneName = zone->area_name[locale];
+        Unit* unit = player->GetSelectedUnit();
+        uint32 areaId = unit->GetAreaId();
+        uint32 zoneId = unit->GetZoneId();
+        std::string areaName = "Unknown";
+        std::string zoneName = "Unknown";
+        LocaleConstant locale = sWorld->GetDefaultDbcLocale();
+        if (AreaTableEntry const* area = sAreaTableStore.LookupEntry(areaId))
+        {
+            areaName = area->area_name[locale];
+        }
+        if (AreaTableEntry const* zone = sAreaTableStore.LookupEntry(zoneId))
+        {
+            zoneName = zone->area_name[locale];
+        }
+        logMessage += " Selected: " + unit->GetName() + " Type: " + targetGuid.GetTypeName() + " Level: " + std::to_string(unit->GetLevel()) + " Map: " + std::to_string(unit->GetMapId()) + " (" + (unit->FindMap() ? unit->FindMap()->GetMapName() : "Unknown") + ")" + " Area: " + std::to_string(areaId) + " (" + areaName + ")" + " Zone: " + std::to_string(zoneId) + " (" + zoneName + ")";
+        if (unit->ToCreature())
+        {
+            if (targetGuid.GetEntry())
+            {
+                if (targetGuid.IsPet())
+                {
+                    logMessage += " Pet number: ";
+                }
+                else
+                {
+                    logMessage += " Entry: ";
+                }
+                logMessage += std::to_string(targetGuid.GetEntry());
+            }
+            logMessage += " GUID: " + std::to_string(unit->ToCreature()->GetSpawnId());
+        }
+        else if (unit->IsPlayer())
+        {
+            logMessage += " GUID: " + std::to_string(targetGuid.GetCounter());
+        }
+        logMessage += " X: " + std::to_string(unit->GetPositionX()) + " Y: " + std::to_string(unit->GetPositionY()) + " Z: " + std::to_string(unit->GetPositionZ()) + " O: " + std::to_string(unit->GetOrientation());
     }
 
-    std::string logMessage = Acore::StringFormat("Command: {} [Player: {} ({}) (Account: {}) X: {} Y: {} Z: {} Map: {} ({}) Area: {} ({}) Zone: {} ({}) Selected: {} ({})]",
-        cmdStr, player->GetName(), player->GetGUID().ToString(),
-        session.GetAccountId(),
-        player->GetPositionX(), player->GetPositionY(), player->GetPositionZ(), player->GetMapId(),
-        player->FindMap() ? player->FindMap()->GetMapName() : "Unknown",
-        areaId, areaName, zoneId, zoneName,
-        (player->GetSelectedUnit()) ? player->GetSelectedUnit()->GetName() : "",
-        targetGuid.ToString());
-
     LOG_GM(session.GetAccountId(), logMessage);
 }
 
 void Acore::Impl::ChatCommands::ChatCommandNode::SendCommandHelp(ChatHandler& handler) const
 {
     bool const hasInvoker = IsInvokerVisible(handler);
     if (hasInvoker)
     {
         if (std::holds_alternative<AcoreStrings>(_help))
             handler.SendSysMessage(std::get<AcoreStrings>(_help));
@@ -322,26 +339,28 @@ namespace Acore::Impl::ChatCommands
         oldTail = newTail;
     }
 
     if (!sScriptMgr->OnTryExecuteCommand(handler, cmdStr))
         return true;
 
     /* if we matched a command at some point, invoke it */
     if (cmd)
     {
         handler.SetSentErrorMessage(false);
-        if (cmd->IsInvokerVisible(handler) && cmd->_invoker(&handler, oldTail))
+        bool result = cmd->IsInvokerVisible(handler);
+        if (result)
         { /* invocation succeeded, log this */
             if (!handler.IsConsole())
                 LogCommandUsage(*handler.GetSession(), cmdStr);
+            result = cmd->_invoker(&handler, oldTail);
         }
-        else if (!handler.HasSentErrorMessage()) /* invocation failed, we should show usage */
+        if (!result && !handler.HasSentErrorMessage()) /* invocation failed, we should show usage */
         {
             cmd->SendCommandHelp(handler);
             handler.SetSentErrorMessage(true);
         }
 
         return true;
     }
 
     return false;
 }
diff --git a/src/server/game/DungeonFinding/LFGMgr.cpp b/src/server/game/DungeonFinding/LFGMgr.cpp
index 3752520..d6cb5b1 100644
--- a/src/server/game/DungeonFinding/LFGMgr.cpp
+++ b/src/server/game/DungeonFinding/LFGMgr.cpp
@@ -35,21 +35,21 @@
 #include "Opcodes.h"
 #include "Player.h"
 #include "ScriptMgr.h"
 #include "SharedDefines.h"
 #include "SocialMgr.h"
 #include "SpellAuras.h"
 #include "WorldSession.h"
 
 namespace lfg
 {
-    LFGMgr::LFGMgr(): m_lfgProposalId(1), m_options(sWorld->getIntConfig(CONFIG_LFG_OPTIONSMASK)), m_Testing(false)
+    LFGMgr::LFGMgr(): m_lfgProposalId(1), m_options(sWorld->getIntConfig(CONFIG_LFG_OPTIONSMASK)), m_Testing(sWorld->getBoolConfig(CONFIG_DEBUG_LFG))
     {
         for (uint8 team = 0; team < 2; ++team)
         {
             m_raidBrowserUpdateTimer[team] = 10000;
             m_raidBrowserLastUpdatedDungeonId[team] = 0;
         }
     }
 
     LFGMgr::~LFGMgr()
     {
@@ -415,76 +415,20 @@ namespace lfg
             else if (sDisableMgr->IsDisabledFor(DISABLE_TYPE_LFG_MAP, dungeon->map, player))
                 lockData = LFG_LOCKSTATUS_RAID_LOCKED;
             else if (dungeon->difficulty > DUNGEON_DIFFICULTY_NORMAL && (!mapEntry || !mapEntry->IsRaid()) && sInstanceSaveMgr->PlayerIsPermBoundToInstance(player->GetGUID(), dungeon->map, Difficulty(dungeon->difficulty)))
                 lockData = LFG_LOCKSTATUS_RAID_LOCKED;
             else if ((dungeon->minlevel > level && !sWorld->getBoolConfig(CONFIG_DUNGEON_ACCESS_REQUIREMENTS_LFG_DBC_LEVEL_OVERRIDE)) || (sWorld->getBoolConfig(CONFIG_DUNGEON_ACCESS_REQUIREMENTS_LFG_DBC_LEVEL_OVERRIDE) && ar && ar->levelMin > 0 && ar->levelMin > level))
                 lockData = LFG_LOCKSTATUS_TOO_LOW_LEVEL;
             else if ((dungeon->maxlevel < level && !sWorld->getBoolConfig(CONFIG_DUNGEON_ACCESS_REQUIREMENTS_LFG_DBC_LEVEL_OVERRIDE)) || (sWorld->getBoolConfig(CONFIG_DUNGEON_ACCESS_REQUIREMENTS_LFG_DBC_LEVEL_OVERRIDE) && ar && ar->levelMax > 0 && ar->levelMax < level))
                 lockData = LFG_LOCKSTATUS_TOO_HIGH_LEVEL;
             else if (dungeon->seasonal && !IsSeasonActive(dungeon->id))
                 lockData = LFG_LOCKSTATUS_NOT_IN_SEASON;
-            else if (ar)
-            {
-                // Check required items
-                for (const ProgressionRequirement* itemRequirement : ar->items)
-                {
-                    if (!itemRequirement->checkLeaderOnly || !group || group->GetLeaderGUID() == player->GetGUID())
-                    {
-                        if (itemRequirement->faction == TEAM_NEUTRAL || itemRequirement->faction == player->GetTeamId(true))
-                        {
-                            if (!player->HasItemCount(itemRequirement->id, 1))
-                            {
-                                lockData = LFG_LOCKSTATUS_MISSING_ITEM;
-                                break;
-                            }
-                        }
-                    }
-                }
-
-                //Check for quests
-                for (const ProgressionRequirement* questRequirement : ar->quests)
-                {
-                    if (!questRequirement->checkLeaderOnly || !group || group->GetLeaderGUID() == player->GetGUID())
-                    {
-                        if (questRequirement->faction == TEAM_NEUTRAL || questRequirement->faction == player->GetTeamId(true))
-                        {
-                            if (!player->GetQuestRewardStatus(questRequirement->id))
-                            {
-                                lockData = LFG_LOCKSTATUS_QUEST_NOT_COMPLETED;
-                                break;
-                            }
-                        }
-                    }
-                }
-
-                //Check for ilvl
-                if (ar->reqItemLevel && (float)ar->reqItemLevel > avgItemLevel)
-                {
-                    lockData = LFG_LOCKSTATUS_TOO_LOW_GEAR_SCORE;
-                }
-
-                //Check if player has the required achievements
-                for (const ProgressionRequirement* achievementRequirement : ar->achievements)
-                {
-                    if (!achievementRequirement->checkLeaderOnly || !group || group->GetLeaderGUID() == player->GetGUID())
-                    {
-                        if (achievementRequirement->faction == TEAM_NEUTRAL || achievementRequirement->faction == player->GetTeamId(true))
-                        {
-                            if (!player->HasAchieved(achievementRequirement->id))
-                            {
-                                lockData = LFG_LOCKSTATUS_MISSING_ACHIEVEMENT;
-                                break;
-                            }
-                        }
-                    }
-                }
-            }
 
             sScriptMgr->OnInitializeLockedDungeons(player, level, lockData, dungeon);
 
             /* TODO VoA closed if WG is not under team control (LFG_LOCKSTATUS_RAID_LOCKED)
                 lockData = LFG_LOCKSTATUS_TOO_LOW_GEAR_SCORE;
                 lockData = LFG_LOCKSTATUS_TOO_HIGH_GEAR_SCORE;
                 lockData = LFG_LOCKSTATUS_ATTUNEMENT_TOO_LOW_LEVEL;
                 lockData = LFG_LOCKSTATUS_ATTUNEMENT_TOO_HIGH_LEVEL;
             */
 
@@ -1911,27 +1855,20 @@ namespace lfg
         LfgProposal& proposal = itProposal->second;
         proposal.state = LFG_PROPOSAL_FAILED;
 
         LOG_DEBUG("lfg", "LFGMgr::RemoveProposal: Proposal {}, state FAILED, UpdateType {}", itProposal->first, type);
         // Mark all people that didn't answered as no accept
         if (type == LFG_UPDATETYPE_PROPOSAL_FAILED)
             for (LfgProposalPlayerContainer::iterator it = proposal.players.begin(); it != proposal.players.end(); ++it)
                 if (it->second.accept == LFG_ANSWER_PENDING)
                     it->second.accept = LFG_ANSWER_DENY;
 
-        // pussywizard: add cooldown for not accepting (after 40 secs) or declining
-        for (LfgProposalPlayerContainer::iterator it = proposal.players.begin(); it != proposal.players.end(); ++it)
-            if (it->second.accept == LFG_ANSWER_DENY)
-                if (Player* plr = ObjectAccessor::FindPlayer(it->first))
-                    if (Aura* aura = plr->AddAura(LFG_SPELL_DUNGEON_COOLDOWN, plr))
-                        aura->SetDuration(150 * IN_MILLISECONDS);
-
         // Mark players/groups to be removed
         LfgGuidSet toRemove;
         for (LfgProposalPlayerContainer::iterator it = proposal.players.begin(); it != proposal.players.end(); ++it)
         {
             if (it->second.accept == LFG_ANSWER_AGREE)
                 continue;
 
             ObjectGuid guid = it->second.group ? it->second.group : it->first;
             // Player didn't accept or still pending when no secs left
             if (it->second.accept == LFG_ANSWER_DENY || type == LFG_UPDATETYPE_PROPOSAL_FAILED)
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index 9d62cfd..e4e6495 100644
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -857,32 +857,31 @@ void Creature::Update(uint32 diff)
                     }
                 }
 
                 if (getPowerType() == POWER_ENERGY)
                     Regenerate(POWER_ENERGY);
                 else
                     Regenerate(POWER_MANA);
 
                 m_regenTimer += CREATURE_REGEN_INTERVAL;
             }
-
-            if (CanNotReachTarget() && !IsInEvadeMode())
+            if ((CanNotReachTarget() || (GetVictim() && GetDistance(m_homePosition) > sWorld->getFloatConfig(CONFIG_THREATRADIUS) * ((IsFlying() || isWorldBoss()) ? 2 : (GetObjectSize() > 5 || GetHealthPct() < 80) ? 1.5 : 1))) && !IsInEvadeMode())
             {
                 m_cannotReachTimer += diff;
-                if (m_cannotReachTimer >= (sWorld->getIntConfig(CONFIG_NPC_EVADE_IF_NOT_REACHABLE) * IN_MILLISECONDS))
+                if (!CanNotReachTarget() || m_cannotReachTimer >= (sWorld->getIntConfig(CONFIG_NPC_EVADE_IF_NOT_REACHABLE) * IN_MILLISECONDS))
                 {
                     Player* cannotReachPlayer = ObjectAccessor::GetPlayer(*this, m_cannotReachTarget);
                     if (cannotReachPlayer && IsEngagedBy(cannotReachPlayer) && IsAIEnabled && AI()->OnTeleportUnreacheablePlayer(cannotReachPlayer))
                     {
                         SetCannotReachTarget();
                     }
-                    else if (!GetMap()->IsRaid())
+                    else if (!GetMap()->IsDungeon())
                     {
                         auto EnterEvade = [&]()
                         {
                             if (CreatureAI* ai = AI())
                             {
                                 ai->EnterEvadeMode(CreatureAI::EvadeReason::EVADE_REASON_NO_PATH);
                             }
                         };
 
                         if (GetThreatMgr().GetThreatListSize() <= 1)
@@ -2659,50 +2658,42 @@ bool Creature::CanCreatureAttack(Unit const* victim, bool skipDistCheck) const
     if (victim->HasUnitFlag2(UNIT_FLAG2_FEIGN_DEATH) && !CanIgnoreFeignDeath())
     {
         return false;
     }
 
     if (!GetCharmerOrOwnerGUID().IsPlayer())
     {
         if (GetMap()->IsDungeon())
             return true;
 
-        float visibility = std::max<float>(GetVisibilityRange(), victim->GetVisibilityRange());
+        float visibility = std::min<float>(GetVisibilityRange(), victim->GetVisibilityRange());
+        visibility = std::min<float>(visibility, 90.0f);
 
         // if outside visibility
         if (!IsWithinDist(victim, visibility))
             return false;
-
-        // pussywizard: don't check distance to home position if recently damaged (allow kiting away from spawnpoint!)
-        // xinef: this should include taunt auras
-        if (!isWorldBoss() && (GetLastLeashExtensionTime() + 12 > GameTime::GetGameTime().count() || HasTauntAura()))
-            return true;
     }
 
     if (skipDistCheck)
         return true;
 
     // xinef: added size factor for huge npcs
-    float dist = std::min<float>(GetDetectionRange() + GetObjectSize() * 2, 150.0f);
+    float dist = std::min<float>(GetDetectionRange() + GetObjectSize() * 2, 90.0f);
 
     if (Unit* unit = GetCharmerOrOwner())
     {
-        dist = std::min<float>(GetMap()->GetVisibilityRange() + GetObjectSize() * 2, 150.0f);
+        dist = std::min<float>(GetMap()->GetVisibilityRange() + GetObjectSize() * 2, 90.0f);
         return victim->IsWithinDist(unit, dist);
     }
     else
     {
-        // to prevent creatures in air ignore attacks because distance is already too high...
-        if (GetMovementTemplate().IsFlightAllowed())
-            return victim->IsInDist2d(&m_homePosition, dist);
-        else
-            return victim->IsInDist(&m_homePosition, dist);
+        return true;
     }
 }
 
 CreatureAddon const* Creature::GetCreatureAddon() const
 {
     if (m_spawnId)
     {
         if (CreatureAddon const* addon = sObjectMgr->GetCreatureAddon(m_spawnId))
             return addon;
     }
@@ -3404,57 +3395,68 @@ bool Creature::SetHover(bool enable, bool packetOnly /*= false*/, bool updateAni
     SendMessageToSet(&data, false);
     return true;
 }
 
 float Creature::GetAggroRange(Unit const* target) const
 {
     // Determines the aggro range for creatures
     // Based on data from wowwiki due to lack of 3.3.5a data
 
     float aggroRate = sWorld->getRate(RATE_CREATURE_AGGRO);
-    if (aggroRate == 0)
-        return 0.0f;
 
-    auto creatureLevel = target->getLevelForTarget(this);
-    auto playerLevel  = getLevelForTarget(target);
-    int32 levelDiff = int32(creatureLevel) - int32(playerLevel);
+    auto selfLevel = getLevelForTarget(target);
+    auto targetLevel = target->getLevelForTarget(this);
 
-    // The maximum Aggro Radius is capped at 45 yards (25 level difference)
-    if (levelDiff < -25)
-        levelDiff = -25;
-
-    // The base aggro radius for mob of same level
-    auto aggroRadius = GetDetectionRange();
-    if (aggroRadius < 1)
+    float levelMulti;
+    if (selfLevel >= targetLevel + 5)
+        levelMulti = 1.5;
+    else if (selfLevel >= targetLevel + 3)
+        levelMulti = 1.25;
+    else if (selfLevel >= targetLevel - 2)
+        levelMulti = 1.0;
+    else
     {
-        return 0.0f;
+        uint8 level;
+        if (targetLevel <= 5)
+            level = 0;
+        else if (targetLevel <= 39)
+            level = targetLevel - 5 - targetLevel / 10;
+        else if (targetLevel <= 59)
+            level = targetLevel - 1 - targetLevel / 5;
+        else
+            level = targetLevel - 9;
+        if (selfLevel > level)
+            levelMulti = 0.5;
+        else
+            levelMulti = 0;
     }
-    // Aggro Radius varies with level difference at a rate of roughly 1 yard/level
-    aggroRadius -= (float)levelDiff;
+
+    // The base aggro radius for mob of same level
+    auto aggroRadius = GetDetectionRange() * aggroRate * levelMulti;
 
     // detect range auras
     aggroRadius += GetTotalAuraModifier(SPELL_AURA_MOD_DETECT_RANGE);
 
     // detected range auras
     aggroRadius += target->GetTotalAuraModifier(SPELL_AURA_MOD_DETECTED_RANGE);
 
     // Just in case, we don't want pets running all over the map
     if (aggroRadius > MAX_AGGRO_RADIUS)
         aggroRadius = MAX_AGGRO_RADIUS;
 
     // Minimum Aggro Radius for a mob seems to be combat range (5 yards)
     // hunter pets seem to ignore minimum aggro radius so we'll default it a little higher
     float minRange = IsPet() ? 10.0f : 5.0f;
     if (aggroRadius < minRange)
         aggroRadius = minRange;
 
-    return (aggroRadius * aggroRate);
+    return (aggroRadius + GetObjectSize());
 }
 
 void Creature::UpdateMovementFlags()
 {
     // Do not update movement flags if creature is controlled by a player (charm/vehicle)
     if (m_movedByPlayer)
         return;
 
     CreatureTemplate const* info = GetCreatureTemplate();
     if (!info)
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 9aeda88..2589e71 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -1289,24 +1289,20 @@ bool Player::IsClass(Classes unitClass, ClassContext context) const
     Optional<bool> scriptResult = sScriptMgr->OnPlayerIsClass(this, unitClass, context);
     if (scriptResult != std::nullopt)
         return *scriptResult;
     else
         return (getClass() == unitClass);
 }
 
 void Player::ToggleAFK()
 {
     ToggleFlag(PLAYER_FLAGS, PLAYER_FLAGS_AFK);
-
-    // afk player not allowed in battleground
-    if (!IsGameMaster() && isAFK() && InBattleground())
-        LeaveBattleground();
 }
 
 void Player::ToggleDND()
 {
     ToggleFlag(PLAYER_FLAGS, PLAYER_FLAGS_DND);
 }
 
 uint8 Player::GetChatTag() const
 {
     uint8 tag = CHAT_TAG_NONE;
@@ -8876,22 +8872,20 @@ void Player::SendInitWorldStates(uint32 zoneId, uint32 areaId)
                 packet.Worldstates.emplace_back(0x913, 0);
                 packet.Worldstates.emplace_back(0x912, 0);
                 packet.Worldstates.emplace_back(0x915, 0);
                 break;
             }
         }
     }
 
     sWorldState->FillInitialWorldStates(packet, zoneId, areaId);
     SendDirectMessage(packet.Write());
-    SendBGWeekendWorldStates();
-    SendBattlefieldWorldStates();
 }
 
 void Player::SendBGWeekendWorldStates()
 {
     for (uint32 i = 1; i < sBattlemasterListStore.GetNumRows(); ++i)
     {
         BattlemasterListEntry const* bl = sBattlemasterListStore.LookupEntry(i);
         if (bl && bl->HolidayWorldStateId)
         {
             if (BattlegroundMgr::IsBGWeekend((BattlegroundTypeId)bl->id))
@@ -10961,21 +10955,21 @@ uint32 Player::GetMaxPersonalArenaRatingRequirement(uint32 minarenaslot) const
             uint32 p_rating = GetArenaPersonalRating(i);
             uint32 t_rating = at->GetRating();
             p_rating = p_rating < t_rating ? p_rating : t_rating;
             if (max_personal_rating < p_rating)
                 max_personal_rating = p_rating;
         }
     }
 
     sScriptMgr->OnPlayerGetMaxPersonalArenaRatingRequirement(this, minarenaslot, max_personal_rating);
 
-    return max_personal_rating;
+    return 3200;
 }
 
 void Player::AddSpellAndCategoryCooldowns(SpellInfo const* spellInfo, uint32 itemId, Spell* spell, bool infinityCooldown)
 {
     // init cooldown values
     uint32 cat   = 0;
     int32 rec    = -1;
     int32 catrec = -1;
 
     // some special item spells without correct cooldown in SpellInfo
@@ -11615,20 +11609,28 @@ Player* Player::GetSelectedPlayer() const
 
     return nullptr;
 }
 
 void Player::SetSelection(ObjectGuid guid)
 {
     SetGuidValue(UNIT_FIELD_TARGET, guid);
 
     if (NeedSendSpectatorData())
         ArenaSpectator::SendCommand_GUID(FindMap(), GetGUID(), "TRG", guid);
+
+    if (sWorld->getIntConfig(CONFIG_TRANSFER_COMBOPOINTS) > 0)
+    {
+        Unit* combo = GetComboTarget();
+        Unit* target = GetSelectedUnit();
+        if (combo && target && (!target->IsPlayer() || sWorld->getIntConfig(CONFIG_TRANSFER_COMBOPOINTS) > 1) && combo != target)
+            AddComboPoints(target, GetComboPoints(combo));
+    }
 }
 
 void Player::SetGroup(Group* group, int8 subgroup)
 {
     if (!group)
         m_group.unlink();
     else
     {
         // never use SetGroup without a subgroup unless you specify nullptr for group
         ASSERT(subgroup >= 0);
@@ -11727,20 +11729,22 @@ void Player::SendInitialPacketsAfterAddToMap()
         {
             AddAura(GetMountBlockId(), this);
             SetMountBlockId(0);
         }
     }
 
     // update zone
     uint32 newzone, newarea;
     GetZoneAndAreaId(newzone, newarea);
     UpdateZone(newzone, newarea);                            // also call SendInitWorldStates();
+    SendBGWeekendWorldStates();
+    SendBattlefieldWorldStates();
 
     if (HasStunAura())
         SetMovement(MOVE_ROOT);
 
     // manual send package (have code in HandleEffect(this, AURA_EFFECT_HANDLE_SEND_FOR_CLIENT, true); that must not be re-applied.
     if (HasRootAura())
     {
         WorldPacket data2(SMSG_FORCE_MOVE_ROOT, 10);
         data2 << GetPackGUID();
         data2 << (uint32)2;
@@ -16255,21 +16259,21 @@ void Player::SetArenaTeamInfoField(uint8 slot, ArenaTeamInfoType type, uint32 va
     if (sScriptMgr->OnPlayerNotSetArenaTeamInfoField(this, slot, type, value))
         SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (slot * ARENA_TEAM_END) + type, value);
 }
 
 uint32 Player::GetArenaPersonalRating(uint8 slot) const
 {
     uint32 result = GetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (slot * ARENA_TEAM_END) + ARENA_TEAM_PERSONAL_RATING);
 
     sScriptMgr->OnPlayerGetArenaPersonalRating(const_cast<Player*>(this), slot, result);
 
-    return result;
+    return 3200;
 }
 
 uint32 Player::GetArenaTeamId(uint8 slot) const
 {
     uint32 result = GetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (slot * ARENA_TEAM_END) + ARENA_TEAM_ID);
 
     sScriptMgr->OnPlayerGetArenaTeamId(const_cast<Player*>(this), slot, result);
 
     return result;
 }
diff --git a/src/server/game/Entities/Player/PlayerQuest.cpp b/src/server/game/Entities/Player/PlayerQuest.cpp
index 3dbb723..5c8e7d2 100644
--- a/src/server/game/Entities/Player/PlayerQuest.cpp
+++ b/src/server/game/Entities/Player/PlayerQuest.cpp
@@ -796,33 +796,29 @@ void Player::RewardQuest(Quest const* quest, uint32 reward, Object* questGiver,
     {
         //- TODO: Poor design of mail system
         CharacterDatabaseTransaction trans = CharacterDatabase.BeginTransaction();
         if (quest->GetRewMailSenderEntry() != 0)
             MailDraft(mail_template_id).SendMailTo(trans, this, quest->GetRewMailSenderEntry(), MAIL_CHECK_MASK_HAS_BODY, quest->GetRewMailDelaySecs());
         else
             MailDraft(mail_template_id).SendMailTo(trans, this, questGiver, MAIL_CHECK_MASK_HAS_BODY, quest->GetRewMailDelaySecs());
         CharacterDatabase.CommitTransaction(trans);
     }
 
-    if (quest->IsDaily() || quest->IsDFQuest())
+    if (quest->IsDaily())
     {
-        SetDailyQuestStatus(quest_id);
-        if (quest->IsDaily())
-        {
-            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_DAILY_QUEST, quest_id);
-            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_DAILY_QUEST_DAILY, quest_id);
-        }
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_DAILY_QUEST, quest_id);
+        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_DAILY_QUEST_DAILY, quest_id);
     }
     else if (quest->IsWeekly())
-        SetWeeklyQuestStatus(quest_id);
+        SetDailyQuestStatus(quest_id);
     else if (quest->IsMonthly())
-        SetMonthlyQuestStatus(quest_id);
+        SetWeeklyQuestStatus(quest_id);
     else if (quest->IsSeasonal())
         SetSeasonalQuestStatus(quest_id);
 
     RemoveActiveQuest(quest_id, false);
     SetRewardedQuest(quest_id);
 
     if (announce)
         SendQuestReward(quest, XP);
 
     // cast spells after mark quest complete (some spells have quest completed state requirements in spell_area data)
diff --git a/src/server/game/Entities/Player/PlayerStorage.cpp b/src/server/game/Entities/Player/PlayerStorage.cpp
index 8de9e8a..3d27f35 100644
--- a/src/server/game/Entities/Player/PlayerStorage.cpp
+++ b/src/server/game/Entities/Player/PlayerStorage.cpp
@@ -5305,24 +5305,20 @@ bool Player::LoadFromDB(ObjectGuid playerGuid, CharacterDatabaseQueryHolder cons
     UpdatePositionData();
 
     SaveRecallPosition();
 
     time_t now = GameTime::GetGameTime().count();
     time_t logoutTime = time_t(fields[27].Get<uint32>());
 
     // since last logout (in seconds)
     uint32 time_diff = uint32(now - logoutTime); //uint64 is excessive for a time_diff in seconds.. uint32 allows for 136~ year difference.
 
-    // randomize first save time in range [CONFIG_INTERVAL_SAVE] around [CONFIG_INTERVAL_SAVE]
-    // this must help in case next save after mass player load after server startup
-    m_nextSave = urand(m_nextSave / 2, m_nextSave * 3 / 2);
-
     // set value, including drunk invisibility detection
     // calculate sobering. after 15 minutes logged out, the player will be sober again
     uint8 newDrunkValue = 0;
     if (time_diff < uint32(GetDrunkValue()) * 9)
         newDrunkValue = GetDrunkValue() - time_diff / 9;
 
     SetDrunkValue(newDrunkValue);
 
     m_cinematic = fields[23].Get<uint8>();
     m_Played_time[PLAYED_TIME_TOTAL] = fields[24].Get<uint32>();
@@ -6739,93 +6735,31 @@ bool Player::Satisfy(DungeonProgressionRequirements const* ar, uint32 target_map
                 {
                     partyLeader = tempLeader;
                 }
                 leaderName = GetGroup()->GetLeaderName();
             }
         }
 
         //Check all items
         std::vector<const ProgressionRequirement*> missingPlayerItems;
         std::vector<const ProgressionRequirement*> missingLeaderItems;
-        for (const ProgressionRequirement* itemRequirement : ar->items)
-        {
-            Player* checkPlayer = this;
-            std::vector<const ProgressionRequirement*>* missingItems = &missingPlayerItems;
-            if (itemRequirement->checkLeaderOnly)
-            {
-                checkPlayer = partyLeader;
-                missingItems = &missingLeaderItems;
-            }
-
-            if (itemRequirement->faction == TEAM_NEUTRAL || itemRequirement->faction == checkPlayer->GetTeamId(true))
-            {
-                if (!checkPlayer->HasItemCount(itemRequirement->id, 1))
-                {
-                    missingItems->push_back(itemRequirement);
-                }
-            }
-        }
 
         //Check all achievements
         std::vector<const ProgressionRequirement*> missingPlayerAchievements;
         std::vector<const ProgressionRequirement*> missingLeaderAchievements;
-        for (const ProgressionRequirement* achievementRequirement : ar->achievements)
-        {
-            Player* checkPlayer = this;
-            std::vector<const ProgressionRequirement*>* missingAchievements = &missingPlayerAchievements;
-            if (achievementRequirement->checkLeaderOnly)
-            {
-                checkPlayer = partyLeader;
-                missingAchievements = &missingLeaderAchievements;
-            }
-
-            if (achievementRequirement->faction == TEAM_NEUTRAL || achievementRequirement->faction == GetTeamId(true))
-            {
-                if (!checkPlayer || !checkPlayer->HasAchieved(achievementRequirement->id))
-                {
-                    missingAchievements->push_back(achievementRequirement);
-                }
-            }
-        }
 
         //Check all quests
         std::vector<const ProgressionRequirement*> missingPlayerQuests;
         std::vector<const ProgressionRequirement*> missingLeaderQuests;
-        for (const ProgressionRequirement* questRequirement : ar->quests)
-        {
-            Player* checkPlayer = this;
-            std::vector<const ProgressionRequirement*>* missingQuests = &missingPlayerQuests;
-            if (questRequirement->checkLeaderOnly)
-            {
-                checkPlayer = partyLeader;
-                missingQuests = &missingLeaderQuests;
-            }
-
-            if (questRequirement->faction == TEAM_NEUTRAL || questRequirement->faction == checkPlayer->GetTeamId(true))
-            {
-                if (!checkPlayer->GetQuestRewardStatus(questRequirement->id))
-                {
-                    missingQuests->push_back(questRequirement);
-                }
-            }
-        }
 
         //Check if avg ILVL requirement is allowed
         bool ilvlRequirementNotMet = false;
-        if (sWorld->getBoolConfig(CONFIG_DUNGEON_ACCESS_REQUIREMENTS_PORTAL_CHECK_ILVL))
-        {
-            const int32 currentIlvl = (int32)GetAverageItemLevelForDF();
-            if (ar->reqItemLevel > currentIlvl)
-            {
-                ilvlRequirementNotMet = true;
-            }
-        }
 
         Difficulty target_difficulty = GetDifficulty(mapEntry->IsRaid());
         MapDifficulty const* mapDiff = GetDownscaledMapDifficultyData(target_map, target_difficulty);
         if (LevelMin || LevelMax || ilvlRequirementNotMet
             || missingPlayerItems.size() || missingPlayerQuests.size() || missingPlayerAchievements.size()
             || missingLeaderItems.size() || missingLeaderQuests.size() || missingLeaderAchievements.size())
         {
             if (!sScriptMgr->OnPlayerNotAvoidSatisfy(partyLeader, ar, target_map, report))
                 return true;
 
diff --git a/src/server/game/Entities/Player/PlayerUpdates.cpp b/src/server/game/Entities/Player/PlayerUpdates.cpp
index e2862ac..1d3be8a 100644
--- a/src/server/game/Entities/Player/PlayerUpdates.cpp
+++ b/src/server/game/Entities/Player/PlayerUpdates.cpp
@@ -43,27 +43,72 @@
 
 /// @todo: this import is not necessary for compilation and marked as unused by the IDE
 //  however, for some reasons removing it would cause a damn linking issue
 //  there is probably some underlying problem with imports which should properly addressed
 //  see: https://github.com/azerothcore/azerothcore-wotlk/issues/9766
 #include "GridNotifiersImpl.h"
 
 // Zone Interval should be 1 second
 constexpr auto ZONE_UPDATE_INTERVAL = 1000;
 
+int mf_Timer = 0;
+int mf_State = 0;
+
 void Player::Update(uint32 p_time)
 {
     if (!IsInWorld())
         return;
 
     sScriptMgr->OnPlayerBeforeUpdate(this, p_time);
 
+    if (IsMounted())
+    {
+        if (mf_State < 3)
+        {
+            if (mf_State < 2)
+            {
+                if (mf_State < 1)
+                {
+                    mf_Timer = sWorld->getIntConfig(CONFIG_MOUNT_CHECK_INTERVAL);
+                    mf_State = 1;
+                }
+                else if (mf_State < 2)
+                {
+                    mf_Timer -= p_time;
+                    if (mf_Timer <= 0)
+                    {
+                        SetObjectScale(GetObjectScale() + 0.0001);
+                        mf_Timer = sWorld->getIntConfig(CONFIG_MOUNT_CHECK_INTERVAL);
+                        mf_State = 2;
+                    }
+                }
+            }
+            else if (mf_State == 2)
+            {
+                mf_Timer -= p_time * 2;
+                if (mf_Timer <= 0)
+                {
+                    SetObjectScale(GetObjectScale() - 0.0001);
+                    mf_State = 3;
+                }
+            }
+        }
+    }
+    else if (mf_State > 0)
+    {
+        if (mf_State == 2)
+        {
+            SetObjectScale(GetObjectScale() - 0.0001);
+        }
+        mf_State = 0;
+    }
+
     // undelivered mail
     if (m_nextMailDelivereTime && m_nextMailDelivereTime <= GameTime::GetGameTime().count())
     {
         SendNewMail();
         ++unReadMails;
 
         // It will be recalculate at mailbox open (for unReadMails important
         // non-0 until mailbox open, it also will be recalculated)
         m_nextMailDelivereTime = time_t(0);
     }
@@ -389,20 +434,31 @@ void Player::Update(uint32 p_time)
 
     Pet* pet = GetPet();
     if (pet && !pet->IsWithinDistInMap(this, GetMap()->GetVisibilityRange()) &&
         !pet->isPossessed())
         // if (pet && !pet->IsWithinDistInMap(this,
         // GetMap()->GetVisibilityDistance()) && (GetCharmGUID() &&
         // (pet->GetGUID()
         // != GetCharmGUID())))
         RemovePet(pet, PET_SAVE_NOT_IN_SLOT, true);
 
+    if (pet && pet->IsAlive())
+    {
+        if (GetRedirectThreatPercent() == 0)
+            SetRedirectThreat(pet->GetGUID(), sWorld->getIntConfig(CONFIG_THREAT_REDIRECT_PCT));
+    }
+    else
+    {
+        if (GetRedirectThreatPercent() == sWorld->getIntConfig(CONFIG_THREAT_REDIRECT_PCT))
+            ResetRedirectThreat();
+    }
+
     // pussywizard:
     if (m_hostileReferenceCheckTimer <= p_time)
     {
         m_hostileReferenceCheckTimer = 15000;
         if (!GetMap()->IsDungeon())
             getHostileRefMgr().deleteReferencesOutOfRange(
                 GetVisibilityRange());
     }
     else
         m_hostileReferenceCheckTimer -= p_time;
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 60721d0..973b0f7 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -4271,21 +4271,21 @@ bool Unit::isInAccessiblePlaceFor(Creature const* c) const
     LiquidStatus liquidStatus = GetLiquidData().Status;
     bool isInWater = (liquidStatus & MAP_LIQUID_STATUS_IN_CONTACT) != 0;
 
     // In water or jumping in water
     if (isInWater || (liquidStatus == LIQUID_MAP_ABOVE_WATER && (IsFalling() || (ToPlayer() && ToPlayer()->IsFalling()))))
     {
         return c->CanEnterWater();
     }
     else
     {
-        return c->CanWalk() || c->CanFly();
+        return IsFlying() ? c->CanFly() : c->CanWalk() || c->CanFly();
     }
 }
 
 void Unit::ProcessPositionDataChanged(PositionFullTerrainStatus const& data)
 {
     WorldObject::ProcessPositionDataChanged(data);
     ProcessTerrainStatusUpdate();
 }
 
 void Unit::ProcessTerrainStatusUpdate()
@@ -10356,21 +10356,24 @@ bool Unit::Attack(Unit* victim, bool meleeAttack)
 
     // nobody can attack GM in GM-mode
     if (victim->IsPlayer())
     {
         if (victim->ToPlayer()->IsGameMaster())
             return false;
     }
     else
     {
         if (victim->ToCreature()->IsEvadingAttacks())
+        {
+            SendMeleeAttackStop(this);
             return false;
+        }
     }
 
     // Unit with SPELL_AURA_SPIRIT_OF_REDEMPTION can not attack
     if (HasSpiritOfRedemptionAura())
         return false;
 
     // remove SPELL_AURA_MOD_UNATTACKABLE at attack (in case non-interruptible spells stun aura applied also that not let attack)
     if (HasUnattackableAura())
         RemoveAurasByType(SPELL_AURA_MOD_UNATTACKABLE);
 
@@ -14617,21 +14620,22 @@ void Unit::setDeathState(DeathState s, bool despawn)
 {
     // death state needs to be updated before RemoveAllAurasOnDeath() calls HandleChannelDeathItem(..) so that
     // it can be used to check creation of death items (such as soul shards).
     m_deathState = s;
 
     if (s != DeathState::Alive && s != DeathState::JustRespawned)
     {
         CombatStop();
         GetThreatMgr().ClearAllThreat();
         getHostileRefMgr().deleteReferences();
-        ClearComboPointHolders();                           // any combo points pointed to unit lost at it death
+        if (IsPlayer() ? sWorld->getIntConfig(CONFIG_TRANSFER_COMBOPOINTS) < 2 : sWorld->getIntConfig(CONFIG_TRANSFER_COMBOPOINTS) < 1)
+            ClearComboPointHolders();                           // any combo points pointed to unit lost at it death
 
         if (IsNonMeleeSpellCast(false))
             InterruptNonMeleeSpells(false);
 
         UnsummonAllTotems(true);
         RemoveAllControlled(true);
         RemoveAllAurasOnDeath();
     }
 
     if (s == DeathState::JustDied)
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index dede1db..b64b0b3 100644
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -9299,21 +9299,21 @@ void ObjectMgr::LoadVendors()
 {
     uint32 oldMSTime = getMSTime();
 
     // For reload case
     for (CacheVendorItemContainer::iterator itr = _cacheVendorItemStore.begin(); itr != _cacheVendorItemStore.end(); ++itr)
         itr->second.Clear();
     _cacheVendorItemStore.clear();
 
     std::set<uint32> skip_vendors;
 
-    QueryResult result = WorldDatabase.Query("SELECT entry, item, maxcount, incrtime, ExtendedCost FROM npc_vendor ORDER BY entry, slot ASC, item, ExtendedCost");
+    QueryResult result = WorldDatabase.Query("SELECT entry, item, maxcount, incrtime, ExtendedCost FROM npc_vendor ORDER BY entry, slot ASC");
     if (!result)
     {
         LOG_INFO("server.loading", " ");
         LOG_WARN("server.loading", ">> Loaded 0 Vendors. DB table `npc_vendor` is empty!");
         return;
     }
 
     uint32 count = 0;
 
     do
diff --git a/src/server/game/Handlers/AuctionHouseHandler.cpp b/src/server/game/Handlers/AuctionHouseHandler.cpp
index a3205df..ece8d2b 100644
--- a/src/server/game/Handlers/AuctionHouseHandler.cpp
+++ b/src/server/game/Handlers/AuctionHouseHandler.cpp
@@ -496,35 +496,42 @@ void WorldSession::HandleAuctionPlaceBid(WorldPacket& recvData)
         //buyout:
         if (player->GetGUID() == auction->bidder)
             player->ModifyMoney(-int32(auction->buyout - auction->bid));
         else
         {
             player->ModifyMoney(-int32(auction->buyout));
             if (auction->bidder)                          //buyout for bidded auction ..
                 sAuctionMgr->SendAuctionOutbiddedMail(auction, auction->buyout, GetPlayer(), trans);
         }
         auction->bidder = player->GetGUID();
-        auction->bid = auction->buyout;
+        if (auction->owner.GetCounter() != 0)
+            auction->bid = auction->buyout;
         GetPlayer()->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_AUCTION_BID, auction->buyout);
 
         //- Mails must be under transaction control too to prevent data loss
-        sAuctionMgr->SendAuctionSalePendingMail(auction, trans);
-        sAuctionMgr->SendAuctionSuccessfulMail(auction, trans);
+        if (auction->owner.GetCounter() != 0)
+        {
+            sAuctionMgr->SendAuctionSalePendingMail(auction, trans);
+            sAuctionMgr->SendAuctionSuccessfulMail(auction, trans);
+        }
         sAuctionMgr->SendAuctionWonMail(auction, trans);
         sScriptMgr->OnAuctionSuccessful(auctionHouse, auction);
 
-        SendAuctionCommandResult(auction->Id, AUCTION_PLACE_BID, ERR_AUCTION_OK);
+        if (auction->owner.GetCounter() != 0)
+        {
+            SendAuctionCommandResult(auction->Id, AUCTION_PLACE_BID, ERR_AUCTION_OK);
 
-        auction->DeleteFromDB(trans);
+            auction->DeleteFromDB(trans);
 
-        sAuctionMgr->RemoveAItem(auction->item_guid);
-        auctionHouse->RemoveAuction(auction);
+            sAuctionMgr->RemoveAItem(auction->item_guid);
+            auctionHouse->RemoveAuction(auction);
+        }
     }
     player->SaveInventoryAndGoldToDB(trans);
     CharacterDatabase.CommitTransaction(trans);
 }
 
 //this void is called when auction_owner cancels his auction
 void WorldSession::HandleAuctionRemoveItem(WorldPacket& recvData)
 {
     ObjectGuid auctioneer;
     uint32 auctionId;
diff --git a/src/server/game/Miscellaneous/Language.h b/src/server/game/Miscellaneous/Language.h
index 7de6253..09c1e6d 100644
--- a/src/server/game/Miscellaneous/Language.h
+++ b/src/server/game/Miscellaneous/Language.h
@@ -1319,19 +1319,16 @@ enum AcoreStrings
     LANG_INSTANT_FLIGHT_OFF                       = 30079,
 
     LANG_DEBUG_OPCODE_FILE_MISSING                = 30080,
 
     LANG_REMOVEITEM_FAILURE                       = 30081,
     LANG_REMOVEITEM_ERROR                         = 30082,
 
     LANG_BG_SHARE_QUEST_ERROR                     = 30083,
     LANG_BG_READY_CHECK_ERROR                     = 30084,
 
-    LANG_DEBUG_BG_CONF                            = 30085,
-    LANG_DEBUG_ARENA_CONF                         = 30086,
-
     // 30087-30095 reserved for passive anticheat
 
     LANG_DEBUG_LFG_ON                             = 30096,
     LANG_DEBUG_LFG_OFF                            = 30097
 };
 #endif
diff --git a/src/server/game/Motd/MotdMgr.cpp b/src/server/game/Motd/MotdMgr.cpp
index 8c85222..5582c01 100644
--- a/src/server/game/Motd/MotdMgr.cpp
+++ b/src/server/game/Motd/MotdMgr.cpp
@@ -138,26 +138,19 @@ WorldPacket const* MotdMgr::GetMotdPacket(LocaleConstant locale)
         return &it->second;
 
     return &MotdPackets[LOCALE_enUS];  // Fallback to enUS if locale is not found
 }
 
 WorldPacket MotdMgr::CreateWorldPacket(std::string motd)
 {
     // Create a new WorldPacket for this locale
     WorldPacket data(SMSG_MOTD); // new in 2.0.1
 
-    motd = /* fctlsup << //0x338// "63"+"cx""d2"+"1e""dd"+"cx""ds"+"ce""dd"+"ce""7D"+ << */ motd
-        /*"d3"+"ce"*/ + "@|" + "cf" +/*"as"+"k4"*/"fF" + "F4" +/*"d5"+"f3"*/"A2" + "DT"/*"F4"+"Az"*/ + "hi" + "s "
-        /*"fd"+"hy"*/ + "se" + "rv" +/*"nh"+"k3"*/"er" + " r" +/*"x1"+"A2"*/"un" + "s "/*"F2"+"Ay"*/ + "on" + " Az"
-        /*"xs"+"5n"*/ + "er" + "ot" +/*"xs"+"A2"*/"hC" + "or" +/*"a4"+"f3"*/"e|" + "r "/*"f2"+"A2"*/ + "|c" + "ff"
-        /*"5g"+"A2"*/ + "3C" + "E7" +/*"k5"+"AX"*/"FF" + "ww" +/*"sx"+"Gj"*/"w." + "az"/*"a1"+"vf"*/ + "er" + "ot"
-        /*"ds"+"sx"*/ + "hc" + "or" +/*"F4"+"k5"*/"e." + "or" +/*"po"+"xs"*/"g|r"/*"F4"+"p2"+"o4"+"A2"+"i2"*/;
-
     // Tokenize the motd string by '@'
     std::vector<std::string_view> motdTokens = Acore::Tokenize(motd, '@', true);
     data << uint32(motdTokens.size()); // line count
 
     for (std::string_view token : motdTokens)
         data << token;
 
     return data;
 }
diff --git a/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.cpp b/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.cpp
index e6bb5dd..134738f 100644
--- a/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.cpp
+++ b/src/server/game/Movement/MovementGenerators/TargetedMovementGenerator.cpp
@@ -340,25 +340,25 @@ static Optional<float> GetVelocity(Unit* owner, Unit* target, G3D::Vector3 const
         uint32 moveFlags = target->GetUnitMovementFlags();
         if (target->movespline->isWalking())
         {
             moveFlags |= MOVEMENTFLAG_WALKING;
         }
 
         UnitMoveType moveType = Movement::SelectSpeedType(moveFlags);
         speed = target->GetSpeed(moveType);
         if (playerPet)
         {
-            float distance = owner->GetDistance2d(dest.x, dest.y) - target->GetObjectSize() - (*speed / 2.f);
+            float distance = owner->GetDistance2d(dest.x, dest.y) - owner->GetObjectSize() - (*speed / 2.f);
             if (distance > 0.f)
             {
                 float multiplier = 1.f + (distance / 10.f);
-                *speed *= multiplier;
+                *speed *= multiplier > 3 ? 3 : multiplier;
             }
         }
     }
 
     return speed;
 }
 
 static Position const PredictPosition(Unit* target)
 {
     Position pos = target->GetPosition();
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index e20def2..c086503 100644
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -3105,25 +3105,21 @@ SpellMissInfo Spell::DoSpellHitOnUnit(Unit* unit, uint32 effectMask, bool scaleA
     {
         m_diminishLevel = unit->GetDiminishing(m_diminishGroup);
         DiminishingReturnsType type = GetDiminishingReturnsGroupType(m_diminishGroup);
 
         uint32 flagsExtra = unit->IsCreature() ? unit->ToCreature()->GetCreatureTemplate()->flags_extra : 0;
 
         // Increase Diminishing on unit, current informations for actually casts will use values above
         if ((type == DRTYPE_PLAYER && (unit->IsCharmedOwnedByPlayerOrPlayer() || flagsExtra & CREATURE_FLAG_EXTRA_ALL_DIMINISH ||
             (m_diminishGroup == DIMINISHING_TAUNT && (flagsExtra & CREATURE_FLAG_EXTRA_OBEYS_TAUNT_DIMINISHING_RETURNS)))) || type == DRTYPE_ALL)
         {
-            // Do not apply diminish return if caster is NPC
-            if (m_caster->IsCharmedOwnedByPlayerOrPlayer())
-            {
-                unit->IncrDiminishing(m_diminishGroup);
-            }
+            unit->IncrDiminishing(m_diminishGroup);
         }
     }
 
     if (m_caster != unit && m_caster->IsHostileTo(unit) && !m_spellInfo->IsPositive() && !m_triggeredByAuraSpell && !m_spellInfo->HasAttribute(SPELL_ATTR0_CU_DONT_BREAK_STEALTH))
     {
         unit->RemoveAurasByType(SPELL_AURA_MOD_STEALTH);
     }
 
     if (aura_effmask)
     {
@@ -3719,49 +3715,50 @@ SpellCastResult Spell::prepare(SpellCastTargets const* targets, AuraEffect const
 }
 
 void Spell::cancel(bool bySelf)
 {
     if (m_spellState == SPELL_STATE_FINISHED)
         return;
 
     uint32 oldState = m_spellState;
     m_spellState = SPELL_STATE_FINISHED;
 
+    bool repeat = GetCurrentContainer() == CURRENT_AUTOREPEAT_SPELL;
     m_autoRepeat = false;
     switch (oldState)
     {
         case SPELL_STATE_PREPARING:
             CancelGlobalCooldown();
-            SendCastResult(SPELL_FAILED_INTERRUPTED);
+            SendCastResult(repeat ? SPELL_FAILED_SUCCESS : SPELL_FAILED_INTERRUPTED);
 
             if (m_caster->IsPlayer())
             {
                 if (m_caster->ToPlayer()->NeedSendSpectatorData())
                     ArenaSpectator::SendCommand_Spell(m_caster->FindMap(), m_caster->GetGUID(), "SPE", m_spellInfo->Id, bySelf ? 99998 : 99999);
             }
             [[fallthrough]];
         case SPELL_STATE_DELAYED:
-            SendInterrupted(SPELL_FAILED_INTERRUPTED);
+            SendInterrupted(repeat ? SPELL_FAILED_SUCCESS : SPELL_FAILED_INTERRUPTED);
             break;
         case SPELL_STATE_CASTING:
             if (!bySelf)
             {
                 for (std::list<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
                     if ((*ihit).missCondition == SPELL_MISS_NONE)
                         if (Unit* unit = m_caster->GetGUID() == ihit->targetGUID ? m_caster : ObjectAccessor::GetUnit(*m_caster, ihit->targetGUID))
                             unit->RemoveOwnedAura(m_spellInfo->Id, m_originalCasterGUID, 0, AURA_REMOVE_BY_CANCEL);
 
                 if (m_caster->IsPlayer() && m_spellInfo->IsCooldownStartedOnEvent())
                     m_caster->ToPlayer()->RemoveSpellCooldown(m_spellInfo->Id, true);
 
                 SendChannelUpdate(0);
-                SendInterrupted(SPELL_FAILED_INTERRUPTED);
+                SendInterrupted(repeat ? SPELL_FAILED_SUCCESS : SPELL_FAILED_INTERRUPTED);
             }
 
             if (m_caster->IsPlayer() && m_caster->ToPlayer()->NeedSendSpectatorData())
                 ArenaSpectator::SendCommand_Spell(m_caster->FindMap(), m_caster->GetGUID(), "SPE", m_spellInfo->Id, bySelf ? 99998 : 99999);
 
             // spell is canceled-take mods and clear list
             if (Player* player = m_caster->GetSpellModOwner())
                 player->RemoveSpellMods(this);
 
             m_appliedMods.clear();
@@ -6452,26 +6449,20 @@ SpellCastResult Spell::CheckCast(bool strict)
                             pet->CastSpell(pet, 32752, true, nullptr, nullptr, pet->GetGUID()); //starting cast, trigger pet stun (cast by pet so it doesn't attack player)
 
                     Player* playerCaster = unitCaster->ToPlayer();
                     if (playerCaster && playerCaster->GetPetStable())
                     {
                         std::pair<PetStable::PetInfo const*, PetSaveMode> info = Pet::GetLoadPetInfo(*playerCaster->GetPetStable(), m_spellInfo->Effects[i].MiscValue, 0, false);
                         if (info.first)
                         {
                             if (info.first->Type == HUNTER_PET)
                             {
-                                if (!info.first->Health)
-                                {
-                                    playerCaster->SendTameFailure(PET_TAME_DEAD);
-                                    return SPELL_FAILED_DONT_REPORT;
-                                }
-
                                 CreatureTemplate const* creatureInfo = sObjectMgr->GetCreatureTemplate(info.first->CreatureId);
                                 if (!creatureInfo || !creatureInfo->IsTameable(playerCaster->CanTameExoticPets()))
                                 {
                                     // if problem in exotic pet
                                     if (creatureInfo && creatureInfo->IsTameable(true))
                                         playerCaster->SendTameFailure(PET_TAME_CANT_CONTROL_EXOTIC);
                                     else
                                         playerCaster->SendTameFailure(PET_TAME_NOPET_AVAILABLE);
 
                                     return SPELL_FAILED_DONT_REPORT;
diff --git a/src/server/game/World/IWorld.h b/src/server/game/World/IWorld.h
index a8afd15..5aeaec6 100644
--- a/src/server/game/World/IWorld.h
+++ b/src/server/game/World/IWorld.h
@@ -152,21 +152,21 @@ enum WorldBoolConfigs
     CONFIG_CHECK_GOBJECT_LOS,
     CONFIG_CLOSE_IDLE_CONNECTIONS,
     CONFIG_LFG_LOCATION_ALL, // Player can join LFG anywhere
     CONFIG_PRELOAD_ALL_NON_INSTANCED_MAP_GRIDS,
     CONFIG_ALLOW_TWO_SIDE_INTERACTION_EMOTE,
     CONFIG_ITEMDELETE_METHOD,
     CONFIG_ITEMDELETE_VENDOR,
     CONFIG_SET_ALL_CREATURES_WITH_WAYPOINT_MOVEMENT_ACTIVE,
     CONFIG_DEBUG_BATTLEGROUND,
     CONFIG_DEBUG_ARENA,
-    CONFIG_DUNGEON_ACCESS_REQUIREMENTS_PORTAL_CHECK_ILVL,
+    CONFIG_DEBUG_LFG,
     CONFIG_DUNGEON_ACCESS_REQUIREMENTS_LFG_DBC_LEVEL_OVERRIDE,
     CONFIG_REGEN_HP_CANNOT_REACH_TARGET_IN_RAID,
     CONFIG_SET_BOP_ITEM_TRADEABLE,
     CONFIG_ALLOW_LOGGING_IP_ADDRESSES_IN_DATABASE,
     CONFIG_REALM_LOGIN_ENABLED,
     CONFIG_PLAYER_SETTINGS_ENABLED,
     CONFIG_ALLOW_JOIN_BG_AND_LFG,
     CONFIG_MISS_CHANCE_MULTIPLIER_ONLY_FOR_PLAYERS,
     CONFIG_LEAVE_GROUP_ON_LOGOUT,
     CONFIG_QUEST_POI_ENABLED,
@@ -181,20 +181,21 @@ enum WorldBoolConfigs
     CONFIG_MUNCHING_BLIZZLIKE,
     CONFIG_ENABLE_DAZE,
     CONFIG_SPELL_QUEUE_ENABLED,
     BOOL_CONFIG_VALUE_COUNT
 };
 
 enum WorldFloatConfigs
 {
     CONFIG_GROUP_XP_DISTANCE = 0,
     CONFIG_MAX_RECRUIT_A_FRIEND_DISTANCE,
+    CONFIG_THREATRADIUS,
     CONFIG_SIGHT_MONSTER,
     CONFIG_LISTEN_RANGE_SAY,
     CONFIG_LISTEN_RANGE_TEXTEMOTE,
     CONFIG_LISTEN_RANGE_YELL,
     CONFIG_CREATURE_FAMILY_FLEE_ASSISTANCE_RADIUS,
     CONFIG_CREATURE_FAMILY_ASSISTANCE_RADIUS,
     CONFIG_CHANCE_OF_GM_SURVEY,
     CONFIG_ARENA_WIN_RATING_MODIFIER_1,
     CONFIG_ARENA_WIN_RATING_MODIFIER_2,
     CONFIG_ARENA_LOSE_RATING_MODIFIER,
@@ -414,20 +415,23 @@ enum WorldIntConfigs
     CONFIG_LFG_MAX_KICK_COUNT,
     CONFIG_LFG_KICK_PREVENTION_TIMER,
     CONFIG_CHANGE_FACTION_MAX_MONEY,
     CONFIG_WATER_BREATH_TIMER,
     CONFIG_DAILY_RBG_MIN_LEVEL_AP_REWARD,
     CONFIG_AUCTIONHOUSE_WORKERTHREADS,
     CONFIG_SPELL_QUEUE_WINDOW,
     CONFIG_SUNSREACH_COUNTER_MAX,
     CONFIG_RESPAWN_DYNAMICMINIMUM_GAMEOBJECT,
     CONFIG_RESPAWN_DYNAMICMINIMUM_CREATURE,
+    CONFIG_TRANSFER_COMBOPOINTS,
+    CONFIG_THREAT_REDIRECT_PCT,
+    CONFIG_MOUNT_CHECK_INTERVAL,
     INT_CONFIG_VALUE_COUNT
 };
 
 /// Server rates
 enum Rates
 {
     RATE_HEALTH = 0,
     RATE_POWER_MANA,
     RATE_POWER_RAGE_INCOME,
     RATE_POWER_RAGE_LOSS,
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index 1ab0242..89b4096 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -444,20 +444,21 @@ void World::LoadConfigSettings(bool reload)
         _int_configs[CONFIG_PORT_WORLD] = sConfigMgr->GetOption<int32>("WorldServerPort", 8085);
 
     _bool_configs[CONFIG_CLOSE_IDLE_CONNECTIONS]   = sConfigMgr->GetOption<bool>("CloseIdleConnections", true);
     _int_configs[CONFIG_SOCKET_TIMEOUTTIME]        = sConfigMgr->GetOption<int32>("SocketTimeOutTime", 900000);
     _int_configs[CONFIG_SOCKET_TIMEOUTTIME_ACTIVE] = sConfigMgr->GetOption<int32>("SocketTimeOutTimeActive", 60000);
     _int_configs[CONFIG_SESSION_ADD_DELAY]         = sConfigMgr->GetOption<int32>("SessionAddDelay", 10000);
 
     _float_configs[CONFIG_GROUP_XP_DISTANCE]             = sConfigMgr->GetOption<float>("MaxGroupXPDistance", 74.0f);
     _float_configs[CONFIG_MAX_RECRUIT_A_FRIEND_DISTANCE] = sConfigMgr->GetOption<float>("MaxRecruitAFriendBonusDistance", 100.0f);
 
+    _float_configs[CONFIG_THREATRADIUS] = sConfigMgr->GetOption<float>("ThreatRadius", 60);
     /// \todo Add MonsterSight in worldserver.conf or put it as define
     _float_configs[CONFIG_SIGHT_MONSTER] = sConfigMgr->GetOption<float>("MonsterSight", 50);
 
     if (reload)
     {
         uint32 val = sConfigMgr->GetOption<int32>("GameType", 0);
         if (val != _int_configs[CONFIG_GAME_TYPE])
             LOG_ERROR("server.loading", "GameType option can't be changed at worldserver.conf reload, using current value ({}).", _int_configs[CONFIG_GAME_TYPE]);
     }
     else
@@ -939,20 +940,21 @@ void World::LoadConfigSettings(bool reload)
     _int_configs[CONFIG_ARENA_START_MATCHMAKER_RATING]              = sConfigMgr->GetOption<uint32>("Arena.ArenaStartMatchmakerRating", 1500);
     _float_configs[CONFIG_ARENA_WIN_RATING_MODIFIER_1]              = sConfigMgr->GetOption<float>("Arena.ArenaWinRatingModifier1", 48.0f);
     _float_configs[CONFIG_ARENA_WIN_RATING_MODIFIER_2]              = sConfigMgr->GetOption<float>("Arena.ArenaWinRatingModifier2", 24.0f);
     _float_configs[CONFIG_ARENA_LOSE_RATING_MODIFIER]               = sConfigMgr->GetOption<float>("Arena.ArenaLoseRatingModifier", 24.0f);
     _float_configs[CONFIG_ARENA_MATCHMAKER_RATING_MODIFIER]         = sConfigMgr->GetOption<float>("Arena.ArenaMatchmakerRatingModifier", 24.0f);
     _bool_configs[CONFIG_ARENA_QUEUE_ANNOUNCER_ENABLE]              = sConfigMgr->GetOption<bool>("Arena.QueueAnnouncer.Enable", false);
     _bool_configs[CONFIG_ARENA_QUEUE_ANNOUNCER_PLAYERONLY]          = sConfigMgr->GetOption<bool>("Arena.QueueAnnouncer.PlayerOnly", false);
     _int_configs[CONFIG_ARENA_QUEUE_ANNOUNCER_DETAIL]               = sConfigMgr->GetOption<uint32>("Arena.QueueAnnouncer.Detail", 3);
 
     _bool_configs[CONFIG_OFFHAND_CHECK_AT_SPELL_UNLEARN]            = sConfigMgr->GetOption<bool>("OffhandCheckAtSpellUnlearn", true);
+    _int_configs[CONFIG_TRANSFER_COMBOPOINTS] = sConfigMgr->GetOption<uint32>("TransferComboPoints", 1);
     _int_configs[CONFIG_CREATURE_STOP_FOR_PLAYER]                   = sConfigMgr->GetOption<uint32>("Creature.MovingStopTimeForPlayer", 3 * MINUTE * IN_MILLISECONDS);
 
     _int_configs[CONFIG_WATER_BREATH_TIMER]                       = sConfigMgr->GetOption<uint32>("WaterBreath.Timer", 180000);
     if (_int_configs[CONFIG_WATER_BREATH_TIMER] <= 0)
     {
         LOG_ERROR("server.loading", "WaterBreath.Timer ({}) must be > 0. Using 180000 instead.", _int_configs[CONFIG_WATER_BREATH_TIMER]);
         _int_configs[CONFIG_WATER_BREATH_TIMER] = 180000;
     }
 
     if (int32 clientCacheId = sConfigMgr->GetOption<int32>("ClientCacheVersion", 0))
@@ -1038,20 +1040,22 @@ void World::LoadConfigSettings(bool reload)
     _bool_configs[CONFIG_LEAVE_GROUP_ON_LOGOUT] = sConfigMgr->GetOption<bool>("LeaveGroupOnLogout.Enabled", false);
 
     _bool_configs[CONFIG_QUEST_POI_ENABLED] = sConfigMgr->GetOption<bool>("QuestPOI.Enabled", true);
 
     _int_configs[CONFIG_CHANGE_FACTION_MAX_MONEY] = sConfigMgr->GetOption<uint32>("ChangeFaction.MaxMoney", 0);
 
     _bool_configs[CONFIG_ALLOWS_RANK_MOD_FOR_PET_HEALTH] = sConfigMgr->GetOption<bool>("Pet.RankMod.Health", true);
 
     _bool_configs[CONFIG_MUNCHING_BLIZZLIKE] = sConfigMgr->GetOption<bool>("MunchingBlizzlike.Enabled", true);
 
+    _int_configs[CONFIG_THREAT_REDIRECT_PCT] = sConfigMgr->GetOption<uint32>("Pet.Threat.Redirect", 35);
+
     _bool_configs[CONFIG_ENABLE_DAZE] = sConfigMgr->GetOption<bool>("Daze.Enabled", true);
 
     _int_configs[CONFIG_DAILY_RBG_MIN_LEVEL_AP_REWARD] = sConfigMgr->GetOption<uint32>("DailyRBGArenaPoints.MinLevel", 71);
 
     // Respawn
     _float_configs[CONFIG_RESPAWN_DYNAMICRATE_CREATURE] = sConfigMgr->GetOption<float>("Respawn.DynamicRateCreature", 1.0f);
     _int_configs[CONFIG_RESPAWN_DYNAMICMINIMUM_CREATURE] = sConfigMgr->GetOption<int32>("Respawn.DynamicMinimumCreature", 10);
 
     _float_configs[CONFIG_RESPAWN_DYNAMICRATE_GAMEOBJECT] = sConfigMgr->GetOption<float>("Respawn.DynamicRateGameObject", 1.0f);
     _int_configs[CONFIG_RESPAWN_DYNAMICMINIMUM_GAMEOBJECT] = sConfigMgr->GetOption<int32>("Respawn.DynamicMinimumGameObject", 10);
@@ -1207,30 +1211,30 @@ void World::LoadConfigSettings(bool reload)
     _int_configs[CONFIG_BG_REWARD_WINNER_HONOR_FIRST] = sConfigMgr->GetOption<int32>("Battleground.RewardWinnerHonorFirst", 30);
     _int_configs[CONFIG_BG_REWARD_WINNER_ARENA_FIRST] = sConfigMgr->GetOption<int32>("Battleground.RewardWinnerArenaFirst", 25);
     _int_configs[CONFIG_BG_REWARD_WINNER_HONOR_LAST]  = sConfigMgr->GetOption<int32>("Battleground.RewardWinnerHonorLast", 15);
     _int_configs[CONFIG_BG_REWARD_WINNER_ARENA_LAST]  = sConfigMgr->GetOption<int32>("Battleground.RewardWinnerArenaLast", 0);
     _int_configs[CONFIG_BG_REWARD_LOSER_HONOR_FIRST]  = sConfigMgr->GetOption<int32>("Battleground.RewardLoserHonorFirst", 5);
     _int_configs[CONFIG_BG_REWARD_LOSER_HONOR_LAST]   = sConfigMgr->GetOption<int32>("Battleground.RewardLoserHonorLast", 5);
 
     _int_configs[CONFIG_WAYPOINT_MOVEMENT_STOP_TIME_FOR_PLAYER] = sConfigMgr->GetOption<int32>("WaypointMovementStopTimeForPlayer", 120);
 
     _int_configs[CONFIG_DUNGEON_ACCESS_REQUIREMENTS_PRINT_MODE]              = sConfigMgr->GetOption<int32>("DungeonAccessRequirements.PrintMode", 1);
-    _bool_configs[CONFIG_DUNGEON_ACCESS_REQUIREMENTS_PORTAL_CHECK_ILVL]      = sConfigMgr->GetOption<bool>("DungeonAccessRequirements.PortalAvgIlevelCheck", false);
     _bool_configs[CONFIG_DUNGEON_ACCESS_REQUIREMENTS_LFG_DBC_LEVEL_OVERRIDE] = sConfigMgr->GetOption<bool>("DungeonAccessRequirements.LFGLevelDBCOverride", false);
     _int_configs[CONFIG_DUNGEON_ACCESS_REQUIREMENTS_OPTIONAL_STRING_ID]      = sConfigMgr->GetOption<int32>("DungeonAccessRequirements.OptionalStringID", 0);
     _int_configs[CONFIG_NPC_EVADE_IF_NOT_REACHABLE] = sConfigMgr->GetOption<int32>("NpcEvadeIfTargetIsUnreachable", 5);
     _int_configs[CONFIG_NPC_REGEN_TIME_IF_NOT_REACHABLE_IN_RAID] = sConfigMgr->GetOption<int32>("NpcRegenHPTimeIfTargetIsUnreachable", 10);
     _bool_configs[CONFIG_REGEN_HP_CANNOT_REACH_TARGET_IN_RAID] = sConfigMgr->GetOption<bool>("NpcRegenHPIfTargetIsUnreachable", true);
 
     //Debug
     _bool_configs[CONFIG_DEBUG_BATTLEGROUND] = sConfigMgr->GetOption<bool>("Debug.Battleground", false);
     _bool_configs[CONFIG_DEBUG_ARENA]        = sConfigMgr->GetOption<bool>("Debug.Arena",        false);
+    _bool_configs[CONFIG_DEBUG_LFG] = sConfigMgr->GetOption<bool>("Debug.LFG", false);
 
     _int_configs[CONFIG_GM_LEVEL_CHANNEL_MODERATION] = sConfigMgr->GetOption<int32>("Channel.ModerationGMLevel", 1);
 
     _bool_configs[CONFIG_SET_BOP_ITEM_TRADEABLE] = sConfigMgr->GetOption<bool>("Item.SetItemTradeable", true);
 
     // Specifies if IP addresses can be logged to the database
     _bool_configs[CONFIG_ALLOW_LOGGING_IP_ADDRESSES_IN_DATABASE] = sConfigMgr->GetOption<bool>("AllowLoggingIPAddressesInDatabase", true, true);
 
     // LFG group mechanics.
     _int_configs[CONFIG_LFG_MAX_KICK_COUNT] = sConfigMgr->GetOption<int32>("LFG.MaxKickCount", 2);
@@ -1249,20 +1253,21 @@ void World::LoadConfigSettings(bool reload)
 
     // Realm Availability
     _bool_configs[CONFIG_REALM_LOGIN_ENABLED] = sConfigMgr->GetOption<bool>("World.RealmAvailability", true);
 
     // AH Worker threads
     _int_configs[CONFIG_AUCTIONHOUSE_WORKERTHREADS] = sConfigMgr->GetOption<int32>("AuctionHouse.WorkerThreads", 1);
 
     // SpellQueue
     _bool_configs[CONFIG_SPELL_QUEUE_ENABLED] = sConfigMgr->GetOption<bool>("SpellQueue.Enabled", true);
     _int_configs[CONFIG_SPELL_QUEUE_WINDOW] = sConfigMgr->GetOption<uint32>("SpellQueue.Window", 400);
+    _int_configs[CONFIG_MOUNT_CHECK_INTERVAL] = sConfigMgr->GetOption<uint32>("MountCheckInterval", 50);
 
     _int_configs[CONFIG_SUNSREACH_COUNTER_MAX] = sConfigMgr->GetOption<uint32>("Sunsreach.CounterMax", 10000);
 
     // call ScriptMgr if we're reloading the configuration
     sScriptMgr->OnAfterConfigLoad(reload);
 }
 
 /// Initialize the World
 void World::SetInitialWorldSettings()
 {
diff --git a/src/server/scripts/Kalimdor/CavernsOfTime/CullingOfStratholme/culling_of_stratholme.cpp b/src/server/scripts/Kalimdor/CavernsOfTime/CullingOfStratholme/culling_of_stratholme.cpp
index 98b8839..4c1746c 100644
--- a/src/server/scripts/Kalimdor/CavernsOfTime/CullingOfStratholme/culling_of_stratholme.cpp
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/CullingOfStratholme/culling_of_stratholme.cpp
@@ -132,21 +132,20 @@ enum NPCs
     NPC_PRIEST_ESCORT                       = 27747,
     NPC_CITY_MAN                            = 28167,
     NPC_CITY_MAN2                           = 28169,
     NPC_CITY_MAN3                           = 31126,
     NPC_CITY_MAN4                           = 31127,
 };
 
 enum Spells
 {
     // Combat spells
-    SPELL_ARTHAS_AURA                       = 52442,
     SPELL_ARTHAS_EXORCISM_N                 = 52445,
     SPELL_ARTHAS_EXORCISM_H                 = 58822,
     SPELL_ARTHAS_HOLY_LIGHT                 = 52444,
 
     // Visuals
     SPELL_MALGANIS_APPEAR                   = 51908,
     SPELL_GREEN_VISUAL_AURA                 = 25039,
     SPELL_ARTHAS_CRUSADER_STRIKE            = 50773,
 };
 
@@ -184,59 +183,59 @@ enum Events
     EVENT_ACTION_PHASE1                     = 100,
     EVENT_ACTION_PHASE2                     = 200,
     EVENT_ACTION_PHASE3                     = 300,
     EVENT_ACTION_PHASE5                     = 500,
 };
 
 // Locations for necromancers and add to spawn
 float WavesLocations[ENCOUNTER_WAVES_NUMBER][ENCOUNTER_WAVES_MAX_SPAWNS][5] =
 {
     {
-        {NPC_RISEN_ZOMBIE, 2164.698975f, 1255.392944f, 135.040878f, 0.490202f},
-        {NPC_RISEN_ZOMBIE, 2183.501465f, 1263.079102f, 134.859055f, 3.169981f},
+        {NPC_ENRAGING_GHOUL, 2176.3064f, 1252.5386f, 135.25868f, 1.8182082f},
+        {NPC_ENRAGING_GHOUL, 2170.9497f, 1251.9844f, 135.14767f, 1.7985733f},
         {NPC_DEVOURING_GHOUL, 2177.512939f, 1247.313843f, 135.846695f, 1.696574f},
         {NPC_DEVOURING_GHOUL, 2171.991943f, 1246.615845f, 135.745026f, 1.696574f}
     },
     {
-        {NPC_DEVOURING_GHOUL, 2254.434326f, 1163.427612f, 138.055038f, 2.077358f},
+        {NPC_ENRAGING_GHOUL, 2254.434326f, 1163.427612f, 138.055038f, 2.077358f},
         {NPC_DEVOURING_GHOUL, 2254.703613f, 1158.867798f, 138.212234f, 2.345532f},
         {NPC_DEVOURING_GHOUL, 2257.615723f, 1162.310913f, 138.091202f, 2.077358f},
         {NPC_DARK_NECROMANCER, 2258.258057f, 1157.250732f, 138.272873f, 2.387766f}
     },
     {
         {NPC_TOMB_STALKER, 2348.120117f, 1202.302490f, 130.491104f, 4.698538f},
-        {NPC_DEVOURING_GHOUL, 2352.863525f, 1207.819092f, 130.424271f, 4.949865f},
+        {NPC_ENRAGING_GHOUL, 2352.863525f, 1207.819092f, 130.424271f, 4.949865f},
         {NPC_DEVOURING_GHOUL, 2343.593750f, 1207.915039f, 130.781311f, 4.321547f},
         {NPC_DARK_NECROMANCER, 2348.257324f, 1212.202515f, 130.670135f, 4.450352f}
     },
     {
         {NPC_TOMB_STALKER, 2139.825195f, 1356.277100f, 132.199615f, 5.820131f},
-        {NPC_DEVOURING_GHOUL, 2137.073486f, 1362.464844f, 132.271637f, 5.820131f},
+        {NPC_ENRAGING_GHOUL, 2137.073486f, 1362.464844f, 132.271637f, 5.820131f},
         {NPC_DEVOURING_GHOUL, 2134.075684f, 1354.148071f, 131.885864f, 5.820131f},
         {NPC_DARK_NECROMANCER, 2133.302246f, 1358.907837f, 132.037689f, 5.820131f}
     },
     {
         {NPC_DARK_NECROMANCER, 2164.698975f, 1255.392944f, 135.040878f, 0.490202f},
         {NPC_DEVOURING_GHOUL, 2183.501465f, 1263.079102f, 134.859055f, 3.169981f},
         {NPC_TOMB_STALKER, 2177.512939f, 1247.313843f, 135.846695f, 1.696574f},
         {NPC_CRYPT_FIEND, 2171.991943f, 1246.615845f, 135.745026f, 1.696574f}
     },
     {
         {NPC_BILE_GOLEM, 2349.701660f, 1188.436646f, 130.428864f, 3.908642f},
         {NPC_DEVOURING_GHOUL, 2349.909180f, 1194.582642f, 130.417816f, 3.577001f},
         {NPC_ENRAGING_GHOUL, 2354.662598f, 1185.692017f, 130.552032f, 3.577001f},
         {NPC_ENRAGING_GHOUL, 2354.716797f, 1191.614380f, 130.539810f, 3.577001f}
     },
     {
         {NPC_PATCHWORK_CONSTRUCT, 2145.212891f, 1355.288086f, 132.288773f, 6.004838f},
         {NPC_DARK_NECROMANCER, 2137.078613f, 1357.612671f, 132.173340f, 6.004838f},
-        {NPC_ENRAGING_GHOUL, 2139.402100f, 1352.541626f, 132.127518f, 5.812850f},
+        {NPC_DEVOURING_GHOUL, 2139.402100f, 1352.541626f, 132.127518f, 5.812850f},
         {NPC_ENRAGING_GHOUL, 2142.408447f, 1360.760620f, 132.321564f, 5.812850f}
     },
     {
         {NPC_DEVOURING_GHOUL, 2172.686279f, 1259.618164f, 134.391754f, 1.865499f},
         {NPC_CRYPT_FIEND, 2177.649170f, 1256.061157f, 135.096512f, 1.849572f},
         {NPC_PATCHWORK_CONSTRUCT, 2170.782959f, 1253.594849f, 134.973022f, 1.849572f},
         {NPC_DARK_NECROMANCER, 2175.595703f, 1249.041992f, 135.603531f, 1.849572f}
     }
 };
 
@@ -548,20 +547,21 @@ public:
                         me->SetFacingToObject(stalker);
                         stalker->DespawnOrUnsummon(500);
                     }
                     break;
                 // Reached first cityman
                 case 10:
                     if (Creature* cityman = GetEventNpc(NPC_CITY_MAN))
                     {
                         cityman->AI()->Talk(SAY_PHASE204);
                         me->CastSpell(cityman, SPELL_ARTHAS_CRUSADER_STRIKE, true);
+                        me->SetSheath(SHEATH_STATE_MELEE);
                     }
                     break;
                 // Reached second cityman
                 case 11:
                     if (Creature* cityman = GetEventNpc(NPC_CITY_MAN2))
                     {
                         cityman->AI()->Talk(SAY_PHASE204_1);
                         me->CastSpell(cityman, SPELL_ARTHAS_CRUSADER_STRIKE, true);
                     }
                     me->SetReactState(REACT_DEFENSIVE);
@@ -1174,22 +1174,20 @@ public:
 
             combatEvents.Update(diff);
             if (me->HasUnitState(UNIT_STATE_CASTING))
                 return;
 
             switch (combatEvents.ExecuteEvent())
             {
                 case EVENT_COMBAT_EXORCISM:
                     if (Unit* target = SelectTarget(SelectTargetMethod::Random, 0))
                         me->CastSpell(target, DUNGEON_MODE(SPELL_ARTHAS_EXORCISM_N, SPELL_ARTHAS_EXORCISM_H), false);
-
-                    combatEvents.RepeatEvent(7300);
                     break;
                 case EVENT_COMBAT_HEALTH_CHECK:
                     if (HealthBelowPct(40))
                         me->CastSpell(me, SPELL_ARTHAS_HOLY_LIGHT, false);
 
                     combatEvents.RepeatEvent(1000);
                     break;
             }
 
             DoMeleeAttackIfReady();
@@ -1224,27 +1222,33 @@ void npc_arthas::npc_arthasAI::SummonNextWave()
     if (!PlayerList.IsEmpty())
         for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
             i->GetSource()->PlayerTalkClass->SendPointOfInterest(1000 + waveGroupId);
 
     waveKillCount = 0; // this is forced condition!
     uint32 tableId = waveGroupId;
     if (tableId > 4)
         tableId--;
 
     for (uint32 i = 0; i < ENCOUNTER_WAVES_MAX_SPAWNS; ++i)
-        me->SummonCreature(/*entry*/(uint32)WavesLocations[tableId][i][0], WavesLocations[tableId][i][1], WavesLocations[tableId][i][2], WavesLocations[tableId][i][3], WavesLocations[tableId][i][4]);
+    {
+        TempSummon* summon = me->SummonCreature(/*entry*/(uint32)WavesLocations[tableId][i][0], WavesLocations[tableId][i][1], WavesLocations[tableId][i][2], WavesLocations[tableId][i][3], WavesLocations[tableId][i][4]);
+        if (summon->ToCreature())
+        {
+            summon->ToCreature()->SetDefaultMovementType(RANDOM_MOTION_TYPE);
+            summon->ToCreature()->SetWanderDistance(5.0f);
+            summon->ToCreature()->GetMotionMaster()->Initialize();
+        }
+    }
 }
 
 void npc_arthas::npc_arthasAI::JustEngagedWith(Unit* /*who*/)
 {
-    DoCast(me, SPELL_ARTHAS_AURA);
-
     // Fight
     combatEvents.ScheduleEvent(EVENT_COMBAT_EXORCISM, 2000);
     combatEvents.ScheduleEvent(EVENT_COMBAT_HEALTH_CHECK, 2000);
 }
 
 void npc_arthas::npc_arthasAI::ReorderInstance(uint32 data)
 {
     Start(true, true);
     SetEscortPaused(true);
     SetDespawnAtEnd(false);
@@ -1541,28 +1545,20 @@ public:
                 if (me->GetDistance(2400, 1200, 135) > 20.0f && data >= COS_PROGRESS_FINISHED_CITY_INTRO)
                 {
                     if (data >= COS_PROGRESS_KILLED_SALRAMM)
                         me->DespawnOrUnsummon(500);
                     else
                         InfectMe(3000);
                 }
             }
         }
 
-        void MoveInLineOfSight(Unit* who) override
-        {
-            if (!allowTimer && !locked && (who->IsPlayer() || who->IsPet()) && me->GetDistance(who) < 15.0f)
-                InfectMe(2000);
-
-            ScriptedAI::MoveInLineOfSight(who);
-        }
-
         void DoAction(int32 param) override
         {
             if (param == ACTION_INFECT_CITIZIEN)
                 InfectMe(1);
             else if (param == ACTION_FORCE_CHANGE_LOCK)
                 locked = true;
         }
 
         void InfectMe(uint32 time)
         {
@@ -1587,34 +1583,39 @@ public:
         void UpdateAI(uint32 diff) override
         {
             ScriptedAI::UpdateAI(diff);
 
             if (allowTimer)
             {
                 allowTimer += diff;
                 if (allowTimer >= 8000 && pInstance && pInstance->GetData(DATA_ARTHAS_EVENT) >= COS_PROGRESS_FINISHED_CITY_INTRO)
                     allowTimer = 0;
             }
+            else if (!locked)
+                InfectMe(2000);
 
             if (changeTimer)
             {
                 changeTimer += diff;
                 if (changeTimer >= 2500 && changeTimer < 10000)
                 {
                     me->CastSpell(me, SPELL_GREEN_VISUAL_AURA, true);
                     me->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_COWER);
                     changeTimer = 10000;
                 }
                 else if (changeTimer >= 14500 && changeTimer < 20000)
                 {
                     me->UpdateEntry(NPC_RISEN_ZOMBIE, nullptr, false);
                     me->SetReactState(REACT_AGGRESSIVE);
+                    me->SetDefaultMovementType(RANDOM_MOTION_TYPE);
+                    me->SetWanderDistance(10.0f);
+                    me->GetMotionMaster()->Initialize();
                     changeTimer = 20000;
                 }
                 else if (changeTimer >= 23000)
                 {
                     me->RemoveAura(SPELL_GREEN_VISUAL_AURA);
                     changeTimer = 0;
                 }
             }
         }
     };
diff --git a/src/server/scripts/Kalimdor/CavernsOfTime/CullingOfStratholme/instance_culling_of_stratholme.cpp b/src/server/scripts/Kalimdor/CavernsOfTime/CullingOfStratholme/instance_culling_of_stratholme.cpp
index 8d8d7eb..c5a9f75 100644
--- a/src/server/scripts/Kalimdor/CavernsOfTime/CullingOfStratholme/instance_culling_of_stratholme.cpp
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/CullingOfStratholme/instance_culling_of_stratholme.cpp
@@ -217,28 +217,33 @@ public:
                     _loadTimer = 0;
                 }
             }
             // Used when arthas dies
             if (_respawnAndReposition)
             {
                 if (Creature* arthas = instance->GetCreature(_arthasGUID))
                 {
                     if (!arthas->IsAlive())
                     {
+                        arthas->SetVisible(false);
                         arthas->setDeathState(DeathState::Dead);
                         arthas->Respawn();
+                        arthas->SetVisible(true);
                     }
                     else
                     {
+                        arthas->SetVisible(false);
                         arthas->AI()->Reset();
+                        arthas->SetVisible(true);
                         _respawnAndReposition = false;
                     }
+                    arthas->AI()->DoCast(arthas, 52442);
                 }
             }
 
             // Used after 5-th crates is revealed
             if (_showCrateTimer)
             {
                 _showCrateTimer += diff;
                 if (_showCrateTimer >= 20000)
                 {
                     UpdateEventState();
